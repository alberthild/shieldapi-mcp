{"version":3,"sources":["../../src/exact/client/scheme.ts","../../src/exact/client/eip3009.ts","../../src/exact/client/permit2.ts","../../src/exact/client/eip2612.ts","../../src/exact/client/erc20approval.ts","../../src/exact/client/register.ts"],"sourcesContent":["import {\n  PaymentRequirements,\n  SchemeNetworkClient,\n  PaymentPayloadResult,\n  PaymentPayloadContext,\n} from \"@x402/core/types\";\nimport { EIP2612_GAS_SPONSORING, ERC20_APPROVAL_GAS_SPONSORING } from \"@x402/extensions\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { AssetTransferMethod } from \"../../types\";\nimport { PERMIT2_ADDRESS, erc20AllowanceAbi } from \"../../constants\";\nimport { getAddress } from \"viem\";\nimport { getEvmChainId } from \"../../utils\";\nimport { createEIP3009Payload } from \"./eip3009\";\nimport { createPermit2Payload } from \"./permit2\";\nimport { signEip2612Permit } from \"./eip2612\";\nimport { signErc20ApprovalTransaction } from \"./erc20approval\";\n\n/**\n * EVM client implementation for the Exact payment scheme.\n * Supports both EIP-3009 (transferWithAuthorization) and Permit2 flows.\n *\n * Routes to the appropriate authorization method based on\n * `requirements.extra.assetTransferMethod`. Defaults to EIP-3009\n * for backward compatibility with older facilitators.\n *\n * When the server advertises `eip2612GasSponsoring` and the asset transfer\n * method is `permit2`, the scheme automatically signs an EIP-2612 permit\n * if the user lacks Permit2 approval. This requires `readContract` on the signer.\n */\nexport class ExactEvmScheme implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClient instance.\n   *\n   * @param signer - The EVM signer for client operations.\n   *   Must support `readContract` for EIP-2612 gas sponsoring.\n   *   Use `createWalletClient(...).extend(publicActions)` or `toClientEvmSigner(account, publicClient)`.\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme.\n   * Routes to EIP-3009 or Permit2 based on requirements.extra.assetTransferMethod.\n   *\n   * For Permit2 flows, if the server advertises `eip2612GasSponsoring` and the\n   * signer supports `readContract`, automatically signs an EIP-2612 permit\n   * when Permit2 allowance is insufficient.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @param context - Optional context with server-declared extensions\n   * @returns Promise resolving to a payment payload result (with optional extensions)\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n    context?: PaymentPayloadContext,\n  ): Promise<PaymentPayloadResult> {\n    const assetTransferMethod =\n      (paymentRequirements.extra?.assetTransferMethod as AssetTransferMethod) ?? \"eip3009\";\n\n    if (assetTransferMethod === \"permit2\") {\n      const result = await createPermit2Payload(this.signer, x402Version, paymentRequirements);\n\n      // Check if EIP-2612 gas sponsoring is advertised and we can handle it\n      const eip2612Extensions = await this.trySignEip2612Permit(\n        paymentRequirements,\n        result,\n        context,\n      );\n\n      if (eip2612Extensions) {\n        return {\n          ...result,\n          extensions: eip2612Extensions,\n        };\n      }\n\n      // EIP-2612 not applicable — try ERC-20 approval gas sponsoring as fallback\n      const erc20Extensions = await this.trySignErc20Approval(paymentRequirements, result, context);\n      if (erc20Extensions) {\n        return {\n          ...result,\n          extensions: erc20Extensions,\n        };\n      }\n\n      return result;\n    }\n\n    return createEIP3009Payload(this.signer, x402Version, paymentRequirements);\n  }\n\n  /**\n   * Attempts to sign an EIP-2612 permit for gasless Permit2 approval.\n   *\n   * Returns extension data if:\n   * 1. Server advertises eip2612GasSponsoring\n   * 2. Signer has readContract capability\n   * 3. Current Permit2 allowance is insufficient\n   *\n   * Returns undefined if the extension should not be used.\n   *\n   * @param requirements - The payment requirements from the server\n   * @param result - The payment payload result from the scheme\n   * @param context - Optional context containing server extensions and metadata\n   * @returns Extension data for EIP-2612 gas sponsoring, or undefined if not applicable\n   */\n  private async trySignEip2612Permit(\n    requirements: PaymentRequirements,\n    result: PaymentPayloadResult,\n    context?: PaymentPayloadContext,\n  ): Promise<Record<string, unknown> | undefined> {\n    // Check if server advertises eip2612GasSponsoring\n    if (!context?.extensions?.[EIP2612_GAS_SPONSORING.key]) {\n      return undefined;\n    }\n\n    // Check that required token metadata is available\n    const tokenName = requirements.extra?.name as string | undefined;\n    const tokenVersion = requirements.extra?.version as string | undefined;\n    if (!tokenName || !tokenVersion) {\n      return undefined;\n    }\n\n    const chainId = getEvmChainId(requirements.network);\n    const tokenAddress = getAddress(requirements.asset) as `0x${string}`;\n\n    // Check if user already has sufficient Permit2 allowance\n    try {\n      const allowance = (await this.signer.readContract({\n        address: tokenAddress,\n        abi: erc20AllowanceAbi,\n        functionName: \"allowance\",\n        args: [this.signer.address, PERMIT2_ADDRESS],\n      })) as bigint;\n\n      if (allowance >= BigInt(requirements.amount)) {\n        return undefined; // Already approved, no need for EIP-2612\n      }\n    } catch {\n      // If we can't check allowance, proceed with EIP-2612 signing\n    }\n\n    // Use the same deadline as the Permit2 authorization\n    const permit2Auth = result.payload?.permit2Authorization as Record<string, unknown> | undefined;\n    const deadline =\n      (permit2Auth?.deadline as string) ??\n      Math.floor(Date.now() / 1000 + requirements.maxTimeoutSeconds).toString();\n\n    // Sign the EIP-2612 permit with the exact Permit2 permitted amount\n    // (the contract enforces permit2612.value == permit.permitted.amount)\n    const info = await signEip2612Permit(\n      this.signer,\n      tokenAddress,\n      tokenName,\n      tokenVersion,\n      chainId,\n      deadline,\n      requirements.amount,\n    );\n\n    return {\n      [EIP2612_GAS_SPONSORING.key]: { info },\n    };\n  }\n\n  /**\n   * Attempts to sign an ERC-20 approval transaction for gasless Permit2 approval.\n   *\n   * This is the fallback path when the token does not support EIP-2612. The client\n   * signs (but does not broadcast) a raw `approve(Permit2, MaxUint256)` transaction.\n   * The facilitator broadcasts it atomically before settling.\n   *\n   * Returns extension data if:\n   * 1. Server advertises erc20ApprovalGasSponsoring\n   * 2. Signer has signTransaction + getTransactionCount capabilities\n   * 3. Current Permit2 allowance is insufficient\n   *\n   * Returns undefined if the extension should not be used.\n   *\n   * @param requirements - The payment requirements from the server\n   * @param _result - The payment payload result from the scheme (unused)\n   * @param context - Optional context containing server extensions and metadata\n   * @returns Extension data for ERC-20 approval gas sponsoring, or undefined if not applicable\n   */\n  private async trySignErc20Approval(\n    requirements: PaymentRequirements,\n    _result: PaymentPayloadResult,\n    context?: PaymentPayloadContext,\n  ): Promise<Record<string, unknown> | undefined> {\n    // Check if server advertises erc20ApprovalGasSponsoring\n    if (!context?.extensions?.[ERC20_APPROVAL_GAS_SPONSORING.key]) {\n      return undefined;\n    }\n\n    // Check that signer has the required capabilities for signing raw transactions\n    if (!this.signer.signTransaction || !this.signer.getTransactionCount) {\n      return undefined;\n    }\n\n    const chainId = getEvmChainId(requirements.network);\n    const tokenAddress = getAddress(requirements.asset) as `0x${string}`;\n\n    // Check if user already has sufficient Permit2 allowance\n    try {\n      const allowance = (await this.signer.readContract({\n        address: tokenAddress,\n        abi: erc20AllowanceAbi,\n        functionName: \"allowance\",\n        args: [this.signer.address, PERMIT2_ADDRESS],\n      })) as bigint;\n\n      if (allowance >= BigInt(requirements.amount)) {\n        return undefined; // Already approved, no need for ERC-20 approval tx\n      }\n    } catch {\n      // If we can't check allowance, proceed with signing\n    }\n\n    // Sign the approve(Permit2, MaxUint256) transaction\n    const info = await signErc20ApprovalTransaction(this.signer, tokenAddress, chainId);\n\n    return {\n      [ERC20_APPROVAL_GAS_SPONSORING.key]: { info },\n    };\n  }\n}\n","import { PaymentRequirements, PaymentPayloadResult } from \"@x402/core/types\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEIP3009Payload } from \"../../types\";\nimport { createNonce, getEvmChainId } from \"../../utils\";\n\n/**\n * Creates an EIP-3009 (transferWithAuthorization) payload.\n *\n * @param signer - The EVM signer for client operations\n * @param x402Version - The x402 protocol version\n * @param paymentRequirements - The payment requirements\n * @returns Promise resolving to a payment payload result\n */\nexport async function createEIP3009Payload(\n  signer: ClientEvmSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayloadResult> {\n  const nonce = createNonce();\n  const now = Math.floor(Date.now() / 1000);\n\n  const authorization: ExactEIP3009Payload[\"authorization\"] = {\n    from: signer.address,\n    to: getAddress(paymentRequirements.payTo),\n    value: paymentRequirements.amount,\n    validAfter: (now - 600).toString(),\n    validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),\n    nonce,\n  };\n\n  const signature = await signEIP3009Authorization(signer, authorization, paymentRequirements);\n\n  const payload: ExactEIP3009Payload = {\n    authorization,\n    signature,\n  };\n\n  return {\n    x402Version,\n    payload,\n  };\n}\n\n/**\n * Sign the EIP-3009 authorization using EIP-712.\n *\n * @param signer - The EVM signer\n * @param authorization - The authorization to sign\n * @param requirements - The payment requirements\n * @returns Promise resolving to the signature\n */\nasync function signEIP3009Authorization(\n  signer: ClientEvmSigner,\n  authorization: ExactEIP3009Payload[\"authorization\"],\n  requirements: PaymentRequirements,\n): Promise<`0x${string}`> {\n  const chainId = getEvmChainId(requirements.network);\n\n  if (!requirements.extra?.name || !requirements.extra?.version) {\n    throw new Error(\n      `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n    );\n  }\n\n  const { name, version } = requirements.extra;\n\n  const domain = {\n    name,\n    version,\n    chainId,\n    verifyingContract: getAddress(requirements.asset),\n  };\n\n  const message = {\n    from: getAddress(authorization.from),\n    to: getAddress(authorization.to),\n    value: BigInt(authorization.value),\n    validAfter: BigInt(authorization.validAfter),\n    validBefore: BigInt(authorization.validBefore),\n    nonce: authorization.nonce,\n  };\n\n  return await signer.signTypedData({\n    domain,\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\",\n    message,\n  });\n}\n","import { PaymentRequirements, PaymentPayloadResult } from \"@x402/core/types\";\nimport { encodeFunctionData, getAddress } from \"viem\";\nimport {\n  permit2WitnessTypes,\n  PERMIT2_ADDRESS,\n  x402ExactPermit2ProxyAddress,\n  erc20ApproveAbi,\n  erc20AllowanceAbi,\n} from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactPermit2Payload } from \"../../types\";\nimport { createPermit2Nonce, getEvmChainId } from \"../../utils\";\n\n/** Maximum uint256 value for unlimited approval. */\nconst MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n/**\n * Creates a Permit2 payload using the x402Permit2Proxy witness pattern.\n * The spender is set to x402Permit2Proxy, which enforces that funds\n * can only be sent to the witness.to address.\n *\n * @param signer - The EVM signer for client operations\n * @param x402Version - The x402 protocol version\n * @param paymentRequirements - The payment requirements\n * @returns Promise resolving to a payment payload result\n */\nexport async function createPermit2Payload(\n  signer: ClientEvmSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayloadResult> {\n  const now = Math.floor(Date.now() / 1000);\n  const nonce = createPermit2Nonce();\n\n  // Lower time bound - allow some clock skew\n  const validAfter = (now - 600).toString();\n  // Upper time bound is enforced by Permit2's deadline field\n  const deadline = (now + paymentRequirements.maxTimeoutSeconds).toString();\n\n  const permit2Authorization: ExactPermit2Payload[\"permit2Authorization\"] = {\n    from: signer.address,\n    permitted: {\n      token: getAddress(paymentRequirements.asset),\n      amount: paymentRequirements.amount,\n    },\n    spender: x402ExactPermit2ProxyAddress,\n    nonce,\n    deadline,\n    witness: {\n      to: getAddress(paymentRequirements.payTo),\n      validAfter,\n    },\n  };\n\n  const signature = await signPermit2Authorization(\n    signer,\n    permit2Authorization,\n    paymentRequirements,\n  );\n\n  const payload: ExactPermit2Payload = {\n    signature,\n    permit2Authorization,\n  };\n\n  return {\n    x402Version,\n    payload,\n  };\n}\n\n/**\n * Sign the Permit2 authorization using EIP-712 with witness data.\n * The signature authorizes the x402Permit2Proxy to transfer tokens on behalf of the signer.\n *\n * @param signer - The EVM signer\n * @param permit2Authorization - The Permit2 authorization parameters\n * @param requirements - The payment requirements\n * @returns Promise resolving to the signature\n */\nasync function signPermit2Authorization(\n  signer: ClientEvmSigner,\n  permit2Authorization: ExactPermit2Payload[\"permit2Authorization\"],\n  requirements: PaymentRequirements,\n): Promise<`0x${string}`> {\n  const chainId = getEvmChainId(requirements.network);\n\n  const domain = {\n    name: \"Permit2\",\n    chainId,\n    verifyingContract: PERMIT2_ADDRESS,\n  };\n\n  const message = {\n    permitted: {\n      token: getAddress(permit2Authorization.permitted.token),\n      amount: BigInt(permit2Authorization.permitted.amount),\n    },\n    spender: getAddress(permit2Authorization.spender),\n    nonce: BigInt(permit2Authorization.nonce),\n    deadline: BigInt(permit2Authorization.deadline),\n    witness: {\n      to: getAddress(permit2Authorization.witness.to),\n      validAfter: BigInt(permit2Authorization.witness.validAfter),\n    },\n  };\n\n  return await signer.signTypedData({\n    domain,\n    types: permit2WitnessTypes,\n    primaryType: \"PermitWitnessTransferFrom\",\n    message,\n  });\n}\n\n/**\n * Creates transaction data to approve Permit2 to spend tokens.\n * The user sends this transaction (paying gas) before using Permit2 flow.\n *\n * @param tokenAddress - The ERC20 token contract address\n * @returns Transaction data to send for approval\n *\n * @example\n * ```typescript\n * const tx = createPermit2ApprovalTx(\"0x...\");\n * await walletClient.sendTransaction({\n *   to: tx.to,\n *   data: tx.data,\n * });\n * ```\n */\nexport function createPermit2ApprovalTx(tokenAddress: `0x${string}`): {\n  to: `0x${string}`;\n  data: `0x${string}`;\n} {\n  const data = encodeFunctionData({\n    abi: erc20ApproveAbi,\n    functionName: \"approve\",\n    args: [PERMIT2_ADDRESS, MAX_UINT256],\n  });\n\n  return {\n    to: getAddress(tokenAddress),\n    data,\n  };\n}\n\n/**\n * Parameters for checking Permit2 allowance.\n * Application provides these to check if approval is needed.\n */\nexport interface Permit2AllowanceParams {\n  tokenAddress: `0x${string}`;\n  ownerAddress: `0x${string}`;\n}\n\n/**\n * Returns contract read parameters for checking Permit2 allowance.\n * Use with a public client to check if the user has approved Permit2.\n *\n * @param params - The allowance check parameters\n * @returns Contract read parameters for checking allowance\n *\n * @example\n * ```typescript\n * const readParams = getPermit2AllowanceReadParams({\n *   tokenAddress: \"0x...\",\n *   ownerAddress: \"0x...\",\n * });\n *\n * const allowance = await publicClient.readContract(readParams);\n * const needsApproval = allowance < requiredAmount;\n * ```\n */\nexport function getPermit2AllowanceReadParams(params: Permit2AllowanceParams): {\n  address: `0x${string}`;\n  abi: typeof erc20AllowanceAbi;\n  functionName: \"allowance\";\n  args: [`0x${string}`, `0x${string}`];\n} {\n  return {\n    address: getAddress(params.tokenAddress),\n    abi: erc20AllowanceAbi,\n    functionName: \"allowance\",\n    args: [getAddress(params.ownerAddress), PERMIT2_ADDRESS],\n  };\n}\n","import { getAddress } from \"viem\";\nimport type { Eip2612GasSponsoringInfo } from \"@x402/extensions\";\nimport { eip2612PermitTypes, eip2612NoncesAbi, PERMIT2_ADDRESS } from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\n\n/**\n * Signs an EIP-2612 permit authorizing the Permit2 contract to spend tokens.\n *\n * This creates a gasless off-chain signature that the facilitator can submit\n * on-chain via `x402Permit2Proxy.settleWithPermit()`.\n *\n * The `permittedAmount` must match the Permit2 `permitted.amount` exactly, as the\n * proxy contract enforces `permit2612.value == permittedAmount`.\n *\n * @param signer - The client EVM signer (must support readContract for nonce query)\n * @param tokenAddress - The ERC-20 token contract address\n * @param tokenName - The token name (from paymentRequirements.extra.name)\n * @param tokenVersion - The token version (from paymentRequirements.extra.version)\n * @param chainId - The chain ID\n * @param deadline - The deadline for the permit (unix timestamp as string)\n * @param permittedAmount - The Permit2 permitted amount (must match exactly)\n * @returns The EIP-2612 gas sponsoring info object\n */\nexport async function signEip2612Permit(\n  signer: ClientEvmSigner,\n  tokenAddress: `0x${string}`,\n  tokenName: string,\n  tokenVersion: string,\n  chainId: number,\n  deadline: string,\n  permittedAmount: string,\n): Promise<Eip2612GasSponsoringInfo> {\n  const owner = signer.address;\n  const spender = getAddress(PERMIT2_ADDRESS);\n\n  // Query the current EIP-2612 nonce from the token contract\n  const nonce = (await signer.readContract({\n    address: tokenAddress,\n    abi: eip2612NoncesAbi,\n    functionName: \"nonces\",\n    args: [owner],\n  })) as bigint;\n\n  // Construct EIP-712 domain for the token's permit function\n  const domain = {\n    name: tokenName,\n    version: tokenVersion,\n    chainId,\n    verifyingContract: tokenAddress,\n  };\n\n  const approvalAmount = BigInt(permittedAmount);\n\n  const message = {\n    owner,\n    spender,\n    value: approvalAmount,\n    nonce,\n    deadline: BigInt(deadline),\n  };\n\n  // Sign the EIP-2612 permit\n  const signature = await signer.signTypedData({\n    domain,\n    types: eip2612PermitTypes,\n    primaryType: \"Permit\",\n    message,\n  });\n\n  return {\n    from: owner,\n    asset: tokenAddress,\n    spender,\n    amount: approvalAmount.toString(),\n    nonce: nonce.toString(),\n    deadline,\n    signature,\n    version: \"1\",\n  };\n}\n","import { encodeFunctionData, getAddress, maxUint256 } from \"viem\";\nimport {\n  ERC20_APPROVAL_GAS_SPONSORING_VERSION,\n  type Erc20ApprovalGasSponsoringInfo,\n} from \"@x402/extensions\";\nimport {\n  PERMIT2_ADDRESS,\n  erc20ApproveAbi,\n  ERC20_APPROVE_GAS_LIMIT,\n  DEFAULT_MAX_FEE_PER_GAS,\n  DEFAULT_MAX_PRIORITY_FEE_PER_GAS,\n} from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\n\n/**\n * Signs an EIP-1559 `approve(Permit2, MaxUint256)` transaction for the given token.\n *\n * The signed transaction is NOT broadcast here — the facilitator broadcasts it\n * atomically before settling the Permit2 payment. This enables Permit2 payments\n * for generic ERC-20 tokens that do NOT implement EIP-2612.\n *\n * Always approves MaxUint256 regardless of the payment amount.\n *\n * @param signer - The client EVM signer (must support signTransaction, getTransactionCount)\n * @param tokenAddress - The ERC-20 token contract address\n * @param chainId - The chain ID\n * @returns The ERC-20 approval gas sponsoring info object\n */\nexport async function signErc20ApprovalTransaction(\n  signer: ClientEvmSigner,\n  tokenAddress: `0x${string}`,\n  chainId: number,\n): Promise<Erc20ApprovalGasSponsoringInfo> {\n  const from = signer.address;\n  const spender = getAddress(PERMIT2_ADDRESS);\n\n  // Encode approve(PERMIT2_ADDRESS, MaxUint256) calldata\n  const data = encodeFunctionData({\n    abi: erc20ApproveAbi,\n    functionName: \"approve\",\n    args: [spender, maxUint256],\n  });\n\n  // Get current nonce for the sender\n  const nonce = await signer.getTransactionCount!({ address: from });\n\n  // Get current fee estimates, with fallback values\n  let maxFeePerGas: bigint;\n  let maxPriorityFeePerGas: bigint;\n  try {\n    const fees = await signer.estimateFeesPerGas!();\n    maxFeePerGas = fees.maxFeePerGas;\n    maxPriorityFeePerGas = fees.maxPriorityFeePerGas;\n  } catch {\n    maxFeePerGas = DEFAULT_MAX_FEE_PER_GAS;\n    maxPriorityFeePerGas = DEFAULT_MAX_PRIORITY_FEE_PER_GAS;\n  }\n\n  // Sign the EIP-1559 transaction (not broadcast)\n  const signedTransaction = await signer.signTransaction!({\n    to: tokenAddress,\n    data,\n    nonce,\n    gas: ERC20_APPROVE_GAS_LIMIT,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    chainId,\n  });\n\n  return {\n    from,\n    asset: tokenAddress,\n    spender,\n    amount: maxUint256.toString(),\n    signedTransaction,\n    version: ERC20_APPROVAL_GAS_SPONSORING_VERSION,\n  };\n}\n","import { x402Client, SelectPaymentRequirements, PaymentPolicy } from \"@x402/core/client\";\nimport { Network } from \"@x402/core/types\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/client/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Client\n */\nexport interface EvmClientConfig {\n  /**\n   * The EVM signer to use for creating payment payloads\n   */\n  signer: ClientEvmSigner;\n\n  /**\n   * Optional payment requirements selector function\n   * If not provided, uses the default selector (first available option)\n   */\n  paymentRequirementsSelector?: SelectPaymentRequirements;\n\n  /**\n   * Optional policies to apply to the client\n   */\n  policies?: PaymentPolicy[];\n\n  /**\n   * Optional specific networks to register\n   * If not provided, registers wildcard support (eip155:*)\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Client instance.\n *\n * This function registers:\n * - V2: eip155:* wildcard scheme with ExactEvmScheme (or specific networks if provided)\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param client - The x402Client instance to register schemes to\n * @param config - Configuration for EVM client registration\n * @returns The client instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/client/register\";\n * import { x402Client } from \"@x402/core/client\";\n * import { privateKeyToAccount } from \"viem/accounts\";\n *\n * const account = privateKeyToAccount(\"0x...\");\n * const client = new x402Client();\n * registerExactEvmScheme(client, { signer: account });\n * ```\n */\nexport function registerExactEvmScheme(client: x402Client, config: EvmClientConfig): x402Client {\n  const evmScheme = new ExactEvmScheme(config.signer);\n\n  // Register V2 scheme\n  // EIP-2612 gas sponsoring is handled internally by the scheme when the\n  // server advertises support - no separate extension registration needed.\n  if (config.networks && config.networks.length > 0) {\n    // Register specific networks\n    config.networks.forEach(network => {\n      client.register(network, evmScheme);\n    });\n  } else {\n    // Register wildcard for all EVM chains\n    client.register(\"eip155:*\", evmScheme);\n  }\n\n  // Register all V1 networks\n  NETWORKS.forEach(network => {\n    client.registerV1(network as Network, new ExactEvmSchemeV1(config.signer));\n  });\n\n  // Apply policies if provided\n  if (config.policies) {\n    config.policies.forEach(policy => {\n      client.registerPolicy(policy);\n    });\n  }\n\n  return client;\n}\n"],"mappings":"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","names":["getAddress","getAddress","getAddress","getAddress","getAddress","encodeFunctionData","getAddress","getAddress","encodeFunctionData","getAddress"]}