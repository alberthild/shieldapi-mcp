{"version":3,"sources":["../../../../src/exact/facilitator/eip3009.ts","../../../../src/exact/facilitator/permit2.ts","../../../../src/exact/facilitator/errors.ts","../../../../src/exact/facilitator/erc20approval.ts","../../../../src/exact/facilitator/scheme.ts","../../../../src/exact/facilitator/register.ts"],"sourcesContent":["import {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../constants\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { getEvmChainId } from \"../../utils\";\nimport { ExactEIP3009Payload } from \"../../types\";\n\nexport interface EIP3009FacilitatorConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492: boolean;\n}\n\n/**\n * Verifies an EIP-3009 payment payload.\n *\n * @param signer - The facilitator signer for contract reads\n * @param payload - The payment payload to verify\n * @param requirements - The payment requirements\n * @param eip3009Payload - The EIP-3009 specific payload\n * @returns Promise resolving to verification response\n */\nexport async function verifyEIP3009(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  eip3009Payload: ExactEIP3009Payload,\n): Promise<VerifyResponse> {\n  const payer = eip3009Payload.authorization.from;\n\n  // Verify scheme matches\n  if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n    return {\n      isValid: false,\n      invalidReason: \"unsupported_scheme\",\n      payer,\n    };\n  }\n\n  // Get chain configuration\n  if (!requirements.extra?.name || !requirements.extra?.version) {\n    return {\n      isValid: false,\n      invalidReason: \"missing_eip712_domain\",\n      payer,\n    };\n  }\n\n  const { name, version } = requirements.extra;\n  const erc20Address = getAddress(requirements.asset);\n\n  // Verify network matches\n  if (payload.accepted.network !== requirements.network) {\n    return {\n      isValid: false,\n      invalidReason: \"network_mismatch\",\n      payer,\n    };\n  }\n\n  // Build typed data for signature verification\n  const permitTypedData = {\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\" as const,\n    domain: {\n      name,\n      version,\n      chainId: getEvmChainId(requirements.network),\n      verifyingContract: erc20Address,\n    },\n    message: {\n      from: eip3009Payload.authorization.from,\n      to: eip3009Payload.authorization.to,\n      value: BigInt(eip3009Payload.authorization.value),\n      validAfter: BigInt(eip3009Payload.authorization.validAfter),\n      validBefore: BigInt(eip3009Payload.authorization.validBefore),\n      nonce: eip3009Payload.authorization.nonce,\n    },\n  };\n\n  // Verify signature\n  try {\n    const recoveredAddress = await signer.verifyTypedData({\n      address: eip3009Payload.authorization.from,\n      ...permitTypedData,\n      signature: eip3009Payload.signature!,\n    });\n\n    if (!recoveredAddress) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_signature\",\n        payer,\n      };\n    }\n  } catch {\n    // Signature verification failed - could be an undeployed smart wallet\n    // Check if smart wallet is deployed\n    const signature = eip3009Payload.signature!;\n    const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n    const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n    if (isSmartWallet) {\n      const payerAddress = eip3009Payload.authorization.from;\n      const bytecode = await signer.getCode({ address: payerAddress });\n\n      if (!bytecode || bytecode === \"0x\") {\n        // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n        const erc6492Data = parseErc6492Signature(signature);\n        const hasDeploymentInfo =\n          erc6492Data.address &&\n          erc6492Data.data &&\n          !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n        if (!hasDeploymentInfo) {\n          // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n            payer: payerAddress,\n          };\n        }\n        // EIP-6492 signature with deployment info - allow through\n      } else {\n        // Wallet is deployed but signature still failed - invalid signature\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer,\n        };\n      }\n    } else {\n      // EOA signature failed\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_signature\",\n        payer,\n      };\n    }\n  }\n\n  // Verify payment recipient matches\n  if (getAddress(eip3009Payload.authorization.to) !== getAddress(requirements.payTo)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n      payer,\n    };\n  }\n\n  // Verify validBefore is in the future (with 6 second buffer for block time)\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(eip3009Payload.authorization.validBefore) < BigInt(now + 6)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n      payer,\n    };\n  }\n\n  // Verify validAfter is not in the future\n  if (BigInt(eip3009Payload.authorization.validAfter) > BigInt(now)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n      payer,\n    };\n  }\n\n  // Check balance\n  try {\n    const balance = (await signer.readContract({\n      address: erc20Address,\n      abi: eip3009ABI,\n      functionName: \"balanceOf\",\n      args: [eip3009Payload.authorization.from],\n    })) as bigint;\n\n    if (BigInt(balance) < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"insufficient_funds\",\n        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check balance, continue with other validations\n  }\n\n  // Verify amount is sufficient\n  if (BigInt(eip3009Payload.authorization.value) < BigInt(requirements.amount)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n      payer,\n    };\n  }\n\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer,\n  };\n}\n\n/**\n * Settles an EIP-3009 payment by executing transferWithAuthorization.\n *\n * @param signer - The facilitator signer for contract writes\n * @param payload - The payment payload to settle\n * @param requirements - The payment requirements\n * @param eip3009Payload - The EIP-3009 specific payload\n * @param config - Facilitator configuration\n * @returns Promise resolving to settlement response\n */\nexport async function settleEIP3009(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  eip3009Payload: ExactEIP3009Payload,\n  config: EIP3009FacilitatorConfig,\n): Promise<SettleResponse> {\n  const payer = eip3009Payload.authorization.from;\n\n  // Re-verify before settling\n  const valid = await verifyEIP3009(signer, payload, requirements, eip3009Payload);\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: payload.accepted.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\",\n      payer,\n    };\n  }\n\n  try {\n    // Parse ERC-6492 signature if applicable\n    const parseResult = parseErc6492Signature(eip3009Payload.signature!);\n    const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n    // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n    if (\n      config.deployERC4337WithEIP6492 &&\n      factoryAddress &&\n      factoryCalldata &&\n      !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n    ) {\n      // Check if smart wallet is already deployed\n      const bytecode = await signer.getCode({ address: payer });\n\n      if (!bytecode || bytecode === \"0x\") {\n        // Wallet not deployed - attempt deployment\n        const deployTx = await signer.sendTransaction({\n          to: factoryAddress as Hex,\n          data: factoryCalldata as Hex,\n        });\n\n        // Wait for deployment transaction\n        await signer.waitForTransactionReceipt({ hash: deployTx });\n      }\n    }\n\n    // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n    const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n    const isECDSA = signatureLength === 130;\n\n    let tx: Hex;\n    if (isECDSA) {\n      // For EOA wallets, parse signature into v, r, s and use that overload\n      const parsedSig = parseSignature(signature);\n\n      tx = await signer.writeContract({\n        address: getAddress(requirements.asset),\n        abi: eip3009ABI,\n        functionName: \"transferWithAuthorization\",\n        args: [\n          getAddress(eip3009Payload.authorization.from),\n          getAddress(eip3009Payload.authorization.to),\n          BigInt(eip3009Payload.authorization.value),\n          BigInt(eip3009Payload.authorization.validAfter),\n          BigInt(eip3009Payload.authorization.validBefore),\n          eip3009Payload.authorization.nonce,\n          (parsedSig.v as number | undefined) || parsedSig.yParity,\n          parsedSig.r,\n          parsedSig.s,\n        ],\n      });\n    } else {\n      // For smart wallets, use the bytes signature overload\n      tx = await signer.writeContract({\n        address: getAddress(requirements.asset),\n        abi: eip3009ABI,\n        functionName: \"transferWithAuthorization\",\n        args: [\n          getAddress(eip3009Payload.authorization.from),\n          getAddress(eip3009Payload.authorization.to),\n          BigInt(eip3009Payload.authorization.value),\n          BigInt(eip3009Payload.authorization.validAfter),\n          BigInt(eip3009Payload.authorization.validBefore),\n          eip3009Payload.authorization.nonce,\n          signature,\n        ],\n      });\n    }\n\n    // Wait for transaction confirmation\n    const receipt = await signer.waitForTransactionReceipt({ hash: tx });\n\n    if (receipt.status !== \"success\") {\n      return {\n        success: false,\n        errorReason: \"invalid_transaction_state\",\n        transaction: tx,\n        network: payload.accepted.network,\n        payer,\n      };\n    }\n\n    return {\n      success: true,\n      transaction: tx,\n      network: payload.accepted.network,\n      payer,\n    };\n  } catch {\n    return {\n      success: false,\n      errorReason: \"transaction_failed\",\n      transaction: \"\",\n      network: payload.accepted.network,\n      payer,\n    };\n  }\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  FacilitatorContext,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport {\n  extractEip2612GasSponsoringInfo,\n  validateEip2612GasSponsoringInfo,\n  extractErc20ApprovalGasSponsoringInfo,\n  ERC20_APPROVAL_GAS_SPONSORING,\n  type Erc20ApprovalGasSponsoringFacilitatorExtension,\n} from \"@x402/extensions\";\nimport type { Eip2612GasSponsoringInfo } from \"@x402/extensions\";\nimport { getAddress } from \"viem\";\nimport {\n  eip3009ABI,\n  PERMIT2_ADDRESS,\n  permit2WitnessTypes,\n  x402ExactPermit2ProxyABI,\n  x402ExactPermit2ProxyAddress,\n  erc20AllowanceAbi,\n} from \"../../constants\";\nimport {\n  ErrPermit2612AmountMismatch,\n  ErrPermit2InvalidAmount,\n  ErrPermit2InvalidDestination,\n  ErrPermit2InvalidNonce,\n  ErrPermit2InvalidOwner,\n  ErrPermit2InvalidSignature,\n  ErrPermit2PaymentTooEarly,\n} from \"./errors\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactPermit2Payload } from \"../../types\";\nimport { getEvmChainId } from \"../../utils\";\nimport { validateErc20ApprovalForPayment } from \"./erc20approval\";\n\n/**\n * Verifies a Permit2 payment payload.\n *\n * Handles all Permit2 verification paths:\n * - Standard: checks on-chain Permit2 allowance\n * - EIP-2612: validates the EIP-2612 permit extension when allowance is insufficient\n * - ERC-20 approval: validates the pre-signed approve tx extension when allowance is insufficient\n *\n * @param signer - The facilitator signer for contract reads\n * @param payload - The payment payload to verify\n * @param requirements - The payment requirements\n * @param permit2Payload - The Permit2 specific payload\n * @param context - Optional facilitator context for extension-provided capabilities\n * @returns Promise resolving to verification response\n */\nexport async function verifyPermit2(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  permit2Payload: ExactPermit2Payload,\n  context?: FacilitatorContext,\n): Promise<VerifyResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n    return {\n      isValid: false,\n      invalidReason: \"unsupported_scheme\",\n      payer,\n    };\n  }\n\n  if (payload.accepted.network !== requirements.network) {\n    return {\n      isValid: false,\n      invalidReason: \"network_mismatch\",\n      payer,\n    };\n  }\n\n  const chainId = getEvmChainId(requirements.network);\n  const tokenAddress = getAddress(requirements.asset);\n\n  if (\n    getAddress(permit2Payload.permit2Authorization.spender) !==\n    getAddress(x402ExactPermit2ProxyAddress)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_spender\",\n      payer,\n    };\n  }\n\n  if (\n    getAddress(permit2Payload.permit2Authorization.witness.to) !== getAddress(requirements.payTo)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_recipient_mismatch\",\n      payer,\n    };\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(permit2Payload.permit2Authorization.deadline) < BigInt(now + 6)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_deadline_expired\",\n      payer,\n    };\n  }\n\n  if (BigInt(permit2Payload.permit2Authorization.witness.validAfter) > BigInt(now)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_not_yet_valid\",\n      payer,\n    };\n  }\n\n  if (BigInt(permit2Payload.permit2Authorization.permitted.amount) < BigInt(requirements.amount)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_insufficient_amount\",\n      payer,\n    };\n  }\n\n  if (getAddress(permit2Payload.permit2Authorization.permitted.token) !== tokenAddress) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_token_mismatch\",\n      payer,\n    };\n  }\n\n  const permit2TypedData = {\n    types: permit2WitnessTypes,\n    primaryType: \"PermitWitnessTransferFrom\" as const,\n    domain: {\n      name: \"Permit2\",\n      chainId,\n      verifyingContract: PERMIT2_ADDRESS,\n    },\n    message: {\n      permitted: {\n        token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n        amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n      },\n      spender: getAddress(permit2Payload.permit2Authorization.spender),\n      nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n      deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n      witness: {\n        to: getAddress(permit2Payload.permit2Authorization.witness.to),\n        validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n      },\n    },\n  };\n\n  try {\n    const isValid = await signer.verifyTypedData({\n      address: payer,\n      ...permit2TypedData,\n      signature: permit2Payload.signature,\n    });\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_permit2_signature\",\n        payer,\n      };\n    }\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_signature\",\n      payer,\n    };\n  }\n\n  // Check Permit2 allowance — if insufficient, try gas sponsoring extensions\n  const allowanceResult = await _verifyPermit2Allowance(\n    signer,\n    payload,\n    requirements,\n    payer,\n    tokenAddress,\n    context,\n  );\n  if (allowanceResult) {\n    return allowanceResult;\n  }\n\n  try {\n    const balance = (await signer.readContract({\n      address: tokenAddress,\n      abi: eip3009ABI,\n      functionName: \"balanceOf\",\n      args: [payer],\n    })) as bigint;\n\n    if (balance < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"insufficient_funds\",\n        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check balance, continue\n  }\n\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer,\n  };\n}\n\n/**\n * Checks Permit2 allowance and validates gas sponsoring extensions if allowance is insufficient.\n *\n * @param signer - The facilitator signer for on-chain reads\n * @param payload - The payment payload\n * @param requirements - The payment requirements\n * @param payer - The payer address\n * @param tokenAddress - The token contract address\n * @param context - Optional facilitator context for extension lookup\n * @returns A VerifyResponse if verification should stop (failure), or null to continue\n */\nasync function _verifyPermit2Allowance(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  payer: `0x${string}`,\n  tokenAddress: `0x${string}`,\n  context?: FacilitatorContext,\n): Promise<VerifyResponse | null> {\n  try {\n    const allowance = (await signer.readContract({\n      address: tokenAddress,\n      abi: erc20AllowanceAbi,\n      functionName: \"allowance\",\n      args: [payer, PERMIT2_ADDRESS],\n    })) as bigint;\n\n    if (allowance >= BigInt(requirements.amount)) {\n      return null; // Sufficient allowance, continue verification\n    }\n\n    // Allowance insufficient — try EIP-2612 gas sponsoring first\n    const eip2612Info = extractEip2612GasSponsoringInfo(payload);\n    if (eip2612Info) {\n      const result = validateEip2612PermitForPayment(eip2612Info, payer, tokenAddress);\n      if (!result.isValid) {\n        return { isValid: false, invalidReason: result.invalidReason!, payer };\n      }\n      return null; // EIP-2612 is valid, allowance will be set atomically during settlement\n    }\n\n    // Try ERC-20 approval gas sponsoring as fallback\n    const erc20GasSponsorshipExtension =\n      context?.getExtension<Erc20ApprovalGasSponsoringFacilitatorExtension>(\n        ERC20_APPROVAL_GAS_SPONSORING.key,\n      );\n    if (erc20GasSponsorshipExtension) {\n      const erc20Info = extractErc20ApprovalGasSponsoringInfo(payload);\n      if (erc20Info) {\n        const result = await validateErc20ApprovalForPayment(erc20Info, payer, tokenAddress);\n        if (!result.isValid) {\n          return { isValid: false, invalidReason: result.invalidReason!, payer };\n        }\n        return null; // ERC-20 approval is valid, will be broadcast before settlement\n      }\n    }\n\n    return { isValid: false, invalidReason: \"permit2_allowance_required\", payer };\n  } catch {\n    // If allowance check fails, validate extensions if present; otherwise proceed optimistically\n    const eip2612Info = extractEip2612GasSponsoringInfo(payload);\n    if (eip2612Info) {\n      const result = validateEip2612PermitForPayment(eip2612Info, payer, tokenAddress);\n      if (!result.isValid) {\n        return { isValid: false, invalidReason: result.invalidReason!, payer };\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Settles a Permit2 payment. Single entry point for all Permit2 settlement paths:\n *\n * 1. EIP-2612 extension present -> settleWithPermit (atomic single tx via contract)\n * 2. ERC-20 approval extension present + extension signer -> broadcast approval + settle (via extension signer)\n * 3. Standard -> settle directly (allowance already on-chain)\n *\n * @param signer - The base facilitator signer for contract writes\n * @param payload - The payment payload to settle\n * @param requirements - The payment requirements\n * @param permit2Payload - The Permit2 specific payload\n * @param context - Optional facilitator context for extension-provided capabilities\n * @returns Promise resolving to settlement response\n */\nexport async function settlePermit2(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  permit2Payload: ExactPermit2Payload,\n  context?: FacilitatorContext,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  const valid = await verifyPermit2(signer, payload, requirements, permit2Payload, context);\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: payload.accepted.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\",\n      payer,\n    };\n  }\n\n  // Branch: EIP-2612 gas sponsoring (atomic settleWithPermit via contract)\n  const eip2612Info = extractEip2612GasSponsoringInfo(payload);\n  if (eip2612Info) {\n    return _settlePermit2WithEIP2612(signer, payload, permit2Payload, eip2612Info);\n  }\n\n  // Branch: ERC-20 approval gas sponsoring (broadcast approval + settle via extension signer)\n  const erc20Info = extractErc20ApprovalGasSponsoringInfo(payload);\n  if (erc20Info) {\n    const erc20GasSponsorshipExtension =\n      context?.getExtension<Erc20ApprovalGasSponsoringFacilitatorExtension>(\n        ERC20_APPROVAL_GAS_SPONSORING.key,\n      );\n    if (erc20GasSponsorshipExtension?.signer) {\n      return _settlePermit2WithERC20Approval(\n        erc20GasSponsorshipExtension.signer,\n        payload,\n        permit2Payload,\n        erc20Info,\n      );\n    }\n  }\n\n  // Branch: standard settle (allowance already on-chain)\n  return _settlePermit2Direct(signer, payload, permit2Payload);\n}\n\n/**\n * Settles via settleWithPermit — includes the EIP-2612 permit atomically in one tx.\n *\n * @param signer - The base facilitator signer\n * @param payload - The payment payload\n * @param permit2Payload - The Permit2 specific payload\n * @param eip2612Info - The EIP-2612 gas sponsoring info from the payload extension\n * @returns Promise resolving to settlement response\n */\nasync function _settlePermit2WithEIP2612(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  permit2Payload: ExactPermit2Payload,\n  eip2612Info: Eip2612GasSponsoringInfo,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n  try {\n    const { v, r, s } = splitEip2612Signature(eip2612Info.signature);\n\n    const tx = await signer.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settleWithPermit\",\n      args: [\n        {\n          value: BigInt(eip2612Info.amount),\n          deadline: BigInt(eip2612Info.deadline),\n          r,\n          s,\n          v,\n        },\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    return _waitAndReturn(signer, tx, payload, payer);\n  } catch (error) {\n    return _mapSettleError(error, payload, payer);\n  }\n}\n\n/**\n * Broadcasts the pre-signed ERC-20 approve tx then settles via the extension signer.\n * Both operations use the extension signer, enabling atomic bundling by production implementations.\n *\n * @param extensionSigner - The extension signer with sendRawTransaction + writeContract\n * @param payload - The payment payload\n * @param permit2Payload - The Permit2 specific payload\n * @param erc20Info - Object containing the signed approval transaction\n * @param erc20Info.signedTransaction - The RLP-encoded signed EIP-1559 approval tx\n * @returns Promise resolving to settlement response\n */\nasync function _settlePermit2WithERC20Approval(\n  extensionSigner: Erc20ApprovalGasSponsoringFacilitatorExtension[\"signer\"] & {},\n  payload: PaymentPayload,\n  permit2Payload: ExactPermit2Payload,\n  erc20Info: { signedTransaction: string },\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  try {\n    const approvalTxHash = await extensionSigner.sendRawTransaction({\n      serializedTransaction: erc20Info.signedTransaction as `0x${string}`,\n    });\n\n    const approvalReceipt = await extensionSigner.waitForTransactionReceipt({\n      hash: approvalTxHash,\n    });\n\n    if (approvalReceipt.status !== \"success\") {\n      return {\n        success: false,\n        errorReason: \"erc20_approval_tx_failed\",\n        transaction: approvalTxHash,\n        network: payload.accepted.network,\n        payer,\n      };\n    }\n\n    const tx = await extensionSigner.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settle\",\n      args: [\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    return _waitAndReturn(extensionSigner, tx, payload, payer);\n  } catch (error) {\n    return _mapSettleError(error, payload, payer);\n  }\n}\n\n/**\n * Standard Permit2 settle — allowance is already on-chain.\n *\n * @param signer - The base facilitator signer\n * @param payload - The payment payload\n * @param permit2Payload - The Permit2 specific payload\n * @returns Promise resolving to settlement response\n */\nasync function _settlePermit2Direct(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  permit2Payload: ExactPermit2Payload,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n  try {\n    const tx = await signer.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settle\",\n      args: [\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    return _waitAndReturn(signer, tx, payload, payer);\n  } catch (error) {\n    return _mapSettleError(error, payload, payer);\n  }\n}\n\n/**\n * Waits for tx receipt and returns the appropriate SettleResponse.\n *\n * @param signer - Signer with waitForTransactionReceipt capability\n * @param tx - The transaction hash to wait for\n * @param payload - The payment payload (for network info)\n * @param payer - The payer address\n * @returns Promise resolving to settlement response\n */\nasync function _waitAndReturn(\n  signer: Pick<FacilitatorEvmSigner, \"waitForTransactionReceipt\">,\n  tx: `0x${string}`,\n  payload: PaymentPayload,\n  payer: `0x${string}`,\n): Promise<SettleResponse> {\n  const receipt = await signer.waitForTransactionReceipt({ hash: tx });\n\n  if (receipt.status !== \"success\") {\n    return {\n      success: false,\n      errorReason: \"invalid_transaction_state\",\n      transaction: tx,\n      network: payload.accepted.network,\n      payer,\n    };\n  }\n\n  return {\n    success: true,\n    transaction: tx,\n    network: payload.accepted.network,\n    payer,\n  };\n}\n\n/**\n * Maps contract revert errors to structured SettleResponse error reasons.\n *\n * @param error - The caught error\n * @param payload - The payment payload (for network info)\n * @param payer - The payer address\n * @returns A failed SettleResponse with mapped error reason\n */\nfunction _mapSettleError(\n  error: unknown,\n  payload: PaymentPayload,\n  payer: `0x${string}`,\n): SettleResponse {\n  let errorReason = \"transaction_failed\";\n  if (error instanceof Error) {\n    const message = error.message;\n    if (message.includes(\"Permit2612AmountMismatch\")) {\n      errorReason = ErrPermit2612AmountMismatch;\n    } else if (message.includes(\"InvalidAmount\")) {\n      errorReason = ErrPermit2InvalidAmount;\n    } else if (message.includes(\"InvalidDestination\")) {\n      errorReason = ErrPermit2InvalidDestination;\n    } else if (message.includes(\"InvalidOwner\")) {\n      errorReason = ErrPermit2InvalidOwner;\n    } else if (message.includes(\"PaymentTooEarly\")) {\n      errorReason = ErrPermit2PaymentTooEarly;\n    } else if (message.includes(\"InvalidSignature\") || message.includes(\"SignatureExpired\")) {\n      errorReason = ErrPermit2InvalidSignature;\n    } else if (message.includes(\"InvalidNonce\")) {\n      errorReason = ErrPermit2InvalidNonce;\n    } else {\n      errorReason = `transaction_failed: ${message.slice(0, 500)}`;\n    }\n  }\n  return {\n    success: false,\n    errorReason,\n    transaction: \"\",\n    network: payload.accepted.network,\n    payer,\n  };\n}\n\n/**\n * Validates EIP-2612 permit extension data for a Permit2 payment.\n *\n * @param info - The EIP-2612 gas sponsoring info\n * @param payer - The expected payer address\n * @param tokenAddress - The expected token address\n * @returns Validation result with optional invalidReason\n */\nfunction validateEip2612PermitForPayment(\n  info: Eip2612GasSponsoringInfo,\n  payer: `0x${string}`,\n  tokenAddress: `0x${string}`,\n): { isValid: boolean; invalidReason?: string } {\n  if (!validateEip2612GasSponsoringInfo(info)) {\n    return { isValid: false, invalidReason: \"invalid_eip2612_extension_format\" };\n  }\n\n  if (getAddress(info.from as `0x${string}`) !== getAddress(payer)) {\n    return { isValid: false, invalidReason: \"eip2612_from_mismatch\" };\n  }\n\n  if (getAddress(info.asset as `0x${string}`) !== tokenAddress) {\n    return { isValid: false, invalidReason: \"eip2612_asset_mismatch\" };\n  }\n\n  if (getAddress(info.spender as `0x${string}`) !== getAddress(PERMIT2_ADDRESS)) {\n    return { isValid: false, invalidReason: \"eip2612_spender_not_permit2\" };\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(info.deadline) < BigInt(now + 6)) {\n    return { isValid: false, invalidReason: \"eip2612_deadline_expired\" };\n  }\n\n  return { isValid: true };\n}\n\n/**\n * Splits a 65-byte EIP-2612 signature into v, r, s components.\n *\n * @param signature - The hex-encoded 65-byte signature\n * @returns Object with v (uint8), r (bytes32), s (bytes32)\n */\nfunction splitEip2612Signature(signature: string): {\n  v: number;\n  r: `0x${string}`;\n  s: `0x${string}`;\n} {\n  const sig = signature.startsWith(\"0x\") ? signature.slice(2) : signature;\n\n  if (sig.length !== 130) {\n    throw new Error(\n      `invalid EIP-2612 signature length: expected 65 bytes (130 hex chars), got ${sig.length / 2} bytes`,\n    );\n  }\n\n  const r = `0x${sig.slice(0, 64)}` as `0x${string}`;\n  const s = `0x${sig.slice(64, 128)}` as `0x${string}`;\n  const v = parseInt(sig.slice(128, 130), 16);\n\n  return { v, r, s };\n}\n","/**\n * Named error reason constants for the exact EVM facilitator.\n *\n * These strings must be character-for-character identical to the Go constants in\n * go/mechanisms/evm/exact/facilitator/errors.go to maintain cross-SDK parity.\n */\n\n// EIP-3009 verify errors\nexport const ErrInvalidScheme = \"invalid_exact_evm_scheme\";\nexport const ErrNetworkMismatch = \"invalid_exact_evm_network_mismatch\";\n\n// Permit2 verify errors\nexport const ErrPermit2InvalidSpender = \"invalid_permit2_spender\";\nexport const ErrPermit2RecipientMismatch = \"invalid_permit2_recipient_mismatch\";\nexport const ErrPermit2DeadlineExpired = \"permit2_deadline_expired\";\nexport const ErrPermit2NotYetValid = \"permit2_not_yet_valid\";\nexport const ErrPermit2InsufficientAmount = \"permit2_insufficient_amount\";\nexport const ErrPermit2TokenMismatch = \"permit2_token_mismatch\";\nexport const ErrPermit2InvalidSignature = \"invalid_permit2_signature\";\nexport const ErrPermit2AllowanceRequired = \"permit2_allowance_required\";\n\n// Permit2 settle errors (from contract reverts)\nexport const ErrPermit2InvalidAmount = \"permit2_invalid_amount\";\nexport const ErrPermit2InvalidDestination = \"permit2_invalid_destination\";\nexport const ErrPermit2InvalidOwner = \"permit2_invalid_owner\";\nexport const ErrPermit2PaymentTooEarly = \"permit2_payment_too_early\";\nexport const ErrPermit2InvalidNonce = \"permit2_invalid_nonce\";\nexport const ErrPermit2612AmountMismatch = \"permit2_2612_amount_mismatch\";\n\n// ERC-20 approval gas sponsoring verify errors\nexport const ErrErc20ApprovalInvalidFormat = \"invalid_erc20_approval_extension_format\";\nexport const ErrErc20ApprovalFromMismatch = \"erc20_approval_from_mismatch\";\nexport const ErrErc20ApprovalAssetMismatch = \"erc20_approval_asset_mismatch\";\nexport const ErrErc20ApprovalSpenderNotPermit2 = \"erc20_approval_spender_not_permit2\";\nexport const ErrErc20ApprovalTxWrongTarget = \"erc20_approval_tx_wrong_target\";\nexport const ErrErc20ApprovalTxWrongSelector = \"erc20_approval_tx_wrong_selector\";\nexport const ErrErc20ApprovalTxWrongSpender = \"erc20_approval_tx_wrong_spender\";\nexport const ErrErc20ApprovalTxInvalidCalldata = \"erc20_approval_tx_invalid_calldata\";\nexport const ErrErc20ApprovalTxSignerMismatch = \"erc20_approval_tx_signer_mismatch\";\nexport const ErrErc20ApprovalTxInvalidSignature = \"erc20_approval_tx_invalid_signature\";\nexport const ErrErc20ApprovalTxParseFailed = \"erc20_approval_tx_parse_failed\";\n","import {\n  getAddress,\n  parseTransaction,\n  decodeFunctionData,\n  recoverTransactionAddress,\n  type TransactionSerialized,\n} from \"viem\";\nimport type { VerifyResponse } from \"@x402/core/types\";\nimport {\n  validateErc20ApprovalGasSponsoringInfo,\n  type Erc20ApprovalGasSponsoringInfo,\n} from \"@x402/extensions\";\nimport { PERMIT2_ADDRESS, erc20ApproveAbi } from \"../../constants\";\nimport {\n  ErrErc20ApprovalInvalidFormat,\n  ErrErc20ApprovalFromMismatch,\n  ErrErc20ApprovalAssetMismatch,\n  ErrErc20ApprovalSpenderNotPermit2,\n  ErrErc20ApprovalTxWrongTarget,\n  ErrErc20ApprovalTxWrongSelector,\n  ErrErc20ApprovalTxWrongSpender,\n  ErrErc20ApprovalTxInvalidCalldata,\n  ErrErc20ApprovalTxSignerMismatch,\n  ErrErc20ApprovalTxInvalidSignature,\n  ErrErc20ApprovalTxParseFailed,\n} from \"./errors\";\n\n/** The approve(address,uint256) function selector */\nconst APPROVE_SELECTOR = \"0x095ea7b3\";\n\n/**\n * Validates ERC-20 approval extension data for a Permit2 payment.\n *\n * Performs comprehensive validation:\n * - Format validation via validateErc20ApprovalGasSponsoringInfo (JSON Schema)\n * - `from` matches payer\n * - `asset` matches token\n * - `spender` is PERMIT2_ADDRESS\n * - Transaction `to` matches token address\n * - Transaction calldata is a valid approve(PERMIT2_ADDRESS, ...) call\n * - Recovered transaction signer matches `from`\n *\n * @param info - The ERC-20 approval gas sponsoring info\n * @param payer - The expected payer address\n * @param tokenAddress - The expected token address\n * @returns Validation result with invalidReason and invalidMessage on failure\n */\nexport async function validateErc20ApprovalForPayment(\n  info: Erc20ApprovalGasSponsoringInfo,\n  payer: `0x${string}`,\n  tokenAddress: `0x${string}`,\n): Promise<Pick<VerifyResponse, \"isValid\" | \"invalidReason\" | \"invalidMessage\">> {\n  if (!validateErc20ApprovalGasSponsoringInfo(info)) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalInvalidFormat,\n      invalidMessage: \"ERC-20 approval extension info failed schema validation\",\n    };\n  }\n\n  if (getAddress(info.from) !== getAddress(payer)) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalFromMismatch,\n      invalidMessage: `Expected from=${payer}, got ${info.from}`,\n    };\n  }\n\n  if (getAddress(info.asset) !== tokenAddress) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalAssetMismatch,\n      invalidMessage: `Expected asset=${tokenAddress}, got ${info.asset}`,\n    };\n  }\n\n  if (getAddress(info.spender) !== getAddress(PERMIT2_ADDRESS)) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalSpenderNotPermit2,\n      invalidMessage: `Expected spender=${PERMIT2_ADDRESS}, got ${info.spender}`,\n    };\n  }\n\n  try {\n    const serializedTx = info.signedTransaction as TransactionSerialized;\n    const tx = parseTransaction(serializedTx);\n\n    if (!tx.to || getAddress(tx.to) !== tokenAddress) {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxWrongTarget,\n        invalidMessage: `Transaction targets ${tx.to ?? \"null\"}, expected ${tokenAddress}`,\n      };\n    }\n\n    const data = tx.data ?? \"0x\";\n    if (!data.startsWith(APPROVE_SELECTOR)) {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxWrongSelector,\n        invalidMessage: `Transaction calldata does not start with approve() selector ${APPROVE_SELECTOR}`,\n      };\n    }\n\n    try {\n      const decoded = decodeFunctionData({\n        abi: erc20ApproveAbi,\n        data: data as `0x${string}`,\n      });\n      const calldataSpender = getAddress(decoded.args[0] as `0x${string}`);\n      if (calldataSpender !== getAddress(PERMIT2_ADDRESS)) {\n        return {\n          isValid: false,\n          invalidReason: ErrErc20ApprovalTxWrongSpender,\n          invalidMessage: `approve() spender is ${calldataSpender}, expected Permit2 ${PERMIT2_ADDRESS}`,\n        };\n      }\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxInvalidCalldata,\n        invalidMessage: \"Failed to decode approve() calldata from the signed transaction\",\n      };\n    }\n\n    try {\n      const recoveredAddress = await recoverTransactionAddress({\n        serializedTransaction: serializedTx,\n      });\n      if (getAddress(recoveredAddress) !== getAddress(payer)) {\n        return {\n          isValid: false,\n          invalidReason: ErrErc20ApprovalTxSignerMismatch,\n          invalidMessage: `Transaction signed by ${recoveredAddress}, expected payer ${payer}`,\n        };\n      }\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxInvalidSignature,\n        invalidMessage: \"Failed to recover signer from the signed transaction\",\n      };\n    }\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalTxParseFailed,\n      invalidMessage: \"Failed to parse the signed transaction\",\n    };\n  }\n\n  return { isValid: true };\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  FacilitatorContext,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmPayloadV2, ExactEIP3009Payload, isPermit2Payload } from \"../../types\";\nimport { verifyEIP3009, settleEIP3009 } from \"./eip3009\";\nimport { verifyPermit2, settlePermit2 } from \"./permit2\";\n\nexport interface ExactEvmSchemeConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme.\n * Thin router that delegates to EIP-3009 or Permit2 based on payload type.\n * All extension handling (EIP-2612, ERC-20 approval gas sponsoring) is owned\n * by the Permit2 functions via FacilitatorContext.\n */\nexport class ExactEvmScheme implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeConfig>;\n\n  /**\n   * Creates a new ExactEvmScheme facilitator instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeConfig,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Returns undefined — EVM has no mechanism-specific extra data.\n   *\n   * @param _ - The network identifier (unused)\n   * @returns undefined\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Returns facilitator wallet addresses for the supported response.\n   *\n   * @param _ - The network identifier (unused, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload. Routes to Permit2 or EIP-3009 based on payload type.\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @param context - Optional facilitator context for extension capabilities\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n    context?: FacilitatorContext,\n  ): Promise<VerifyResponse> {\n    const rawPayload = payload.payload as ExactEvmPayloadV2;\n\n    if (isPermit2Payload(rawPayload)) {\n      return verifyPermit2(this.signer, payload, requirements, rawPayload, context);\n    }\n\n    const eip3009Payload: ExactEIP3009Payload = rawPayload;\n    return verifyEIP3009(this.signer, payload, requirements, eip3009Payload);\n  }\n\n  /**\n   * Settles a payment. Routes to Permit2 or EIP-3009 based on payload type.\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @param context - Optional facilitator context for extension capabilities\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n    context?: FacilitatorContext,\n  ): Promise<SettleResponse> {\n    const rawPayload = payload.payload as ExactEvmPayloadV2;\n\n    if (isPermit2Payload(rawPayload)) {\n      return settlePermit2(this.signer, payload, requirements, rawPayload, context);\n    }\n\n    const eip3009Payload: ExactEIP3009Payload = rawPayload;\n    return settleEIP3009(this.signer, payload, requirements, eip3009Payload, this.config);\n  }\n}\n","import { x402Facilitator } from \"@x402/core/facilitator\";\nimport { Network } from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/facilitator/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Facilitator\n */\nexport interface EvmFacilitatorConfig {\n  /**\n   * The EVM signer for facilitator operations (verify and settle)\n   */\n  signer: FacilitatorEvmSigner;\n\n  /**\n   * Networks to register (single network or array of networks)\n   * Examples: \"eip155:84532\", [\"eip155:84532\", \"eip155:1\"]\n   */\n  networks: Network | Network[];\n\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Facilitator instance.\n *\n * This function registers:\n * - V2: Specified networks with ExactEvmScheme\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param facilitator - The x402Facilitator instance to register schemes to\n * @param config - Configuration for EVM facilitator registration\n * @returns The facilitator instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/facilitator/register\";\n * import { x402Facilitator } from \"@x402/core/facilitator\";\n * import { createPublicClient, createWalletClient } from \"viem\";\n *\n * const facilitator = new x402Facilitator();\n *\n * // Single network\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: \"eip155:84532\"  // Base Sepolia\n * });\n *\n * // Multiple networks (will auto-derive eip155:* pattern)\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: [\"eip155:84532\", \"eip155:1\"]  // Base Sepolia and Mainnet\n * });\n * ```\n */\nexport function registerExactEvmScheme(\n  facilitator: x402Facilitator,\n  config: EvmFacilitatorConfig,\n): x402Facilitator {\n  // Register V2 scheme with specified networks\n  facilitator.register(\n    config.networks,\n    new ExactEvmScheme(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  // Register all V1 networks\n  facilitator.registerV1(\n    NETWORKS as Network[],\n    new ExactEvmSchemeV1(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  return facilitator;\n}\n"],"mappings":"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","names":["getAddress","getAddress","getAddress","getAddress"]}