import {
  isPermit2Payload
} from "../../chunk-TKN5V2BV.mjs";
import {
  ExactEvmSchemeV1,
  NETWORKS,
  PERMIT2_ADDRESS,
  authorizationTypes,
  eip3009ABI,
  erc20AllowanceAbi,
  erc20ApproveAbi,
  getEvmChainId,
  permit2WitnessTypes,
  x402ExactPermit2ProxyABI,
  x402ExactPermit2ProxyAddress
} from "../../chunk-7KHQD5KT.mjs";

// src/exact/facilitator/eip3009.ts
import { getAddress, isAddressEqual, parseErc6492Signature, parseSignature } from "viem";
async function verifyEIP3009(signer, payload, requirements, eip3009Payload) {
  const payer = eip3009Payload.authorization.from;
  if (payload.accepted.scheme !== "exact" || requirements.scheme !== "exact") {
    return {
      isValid: false,
      invalidReason: "unsupported_scheme",
      payer
    };
  }
  if (!requirements.extra?.name || !requirements.extra?.version) {
    return {
      isValid: false,
      invalidReason: "missing_eip712_domain",
      payer
    };
  }
  const { name, version } = requirements.extra;
  const erc20Address = getAddress(requirements.asset);
  if (payload.accepted.network !== requirements.network) {
    return {
      isValid: false,
      invalidReason: "network_mismatch",
      payer
    };
  }
  const permitTypedData = {
    types: authorizationTypes,
    primaryType: "TransferWithAuthorization",
    domain: {
      name,
      version,
      chainId: getEvmChainId(requirements.network),
      verifyingContract: erc20Address
    },
    message: {
      from: eip3009Payload.authorization.from,
      to: eip3009Payload.authorization.to,
      value: BigInt(eip3009Payload.authorization.value),
      validAfter: BigInt(eip3009Payload.authorization.validAfter),
      validBefore: BigInt(eip3009Payload.authorization.validBefore),
      nonce: eip3009Payload.authorization.nonce
    }
  };
  try {
    const recoveredAddress = await signer.verifyTypedData({
      address: eip3009Payload.authorization.from,
      ...permitTypedData,
      signature: eip3009Payload.signature
    });
    if (!recoveredAddress) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_signature",
        payer
      };
    }
  } catch {
    const signature = eip3009Payload.signature;
    const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
    const isSmartWallet = signatureLength > 130;
    if (isSmartWallet) {
      const payerAddress = eip3009Payload.authorization.from;
      const bytecode = await signer.getCode({ address: payerAddress });
      if (!bytecode || bytecode === "0x") {
        const erc6492Data = parseErc6492Signature(signature);
        const hasDeploymentInfo = erc6492Data.address && erc6492Data.data && !isAddressEqual(erc6492Data.address, "0x0000000000000000000000000000000000000000");
        if (!hasDeploymentInfo) {
          return {
            isValid: false,
            invalidReason: "invalid_exact_evm_payload_undeployed_smart_wallet",
            payer: payerAddress
          };
        }
      } else {
        return {
          isValid: false,
          invalidReason: "invalid_exact_evm_payload_signature",
          payer
        };
      }
    } else {
      return {
        isValid: false,
        invalidReason: "invalid_exact_evm_payload_signature",
        payer
      };
    }
  }
  if (getAddress(eip3009Payload.authorization.to) !== getAddress(requirements.payTo)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_recipient_mismatch",
      payer
    };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(eip3009Payload.authorization.validBefore) < BigInt(now + 6)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_valid_before",
      payer
    };
  }
  if (BigInt(eip3009Payload.authorization.validAfter) > BigInt(now)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_valid_after",
      payer
    };
  }
  try {
    const balance = await signer.readContract({
      address: erc20Address,
      abi: eip3009ABI,
      functionName: "balanceOf",
      args: [eip3009Payload.authorization.from]
    });
    if (BigInt(balance) < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "insufficient_funds",
        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
        payer
      };
    }
  } catch {
  }
  if (BigInt(eip3009Payload.authorization.value) < BigInt(requirements.amount)) {
    return {
      isValid: false,
      invalidReason: "invalid_exact_evm_payload_authorization_value",
      payer
    };
  }
  return {
    isValid: true,
    invalidReason: void 0,
    payer
  };
}
async function settleEIP3009(signer, payload, requirements, eip3009Payload, config) {
  const payer = eip3009Payload.authorization.from;
  const valid = await verifyEIP3009(signer, payload, requirements, eip3009Payload);
  if (!valid.isValid) {
    return {
      success: false,
      network: payload.accepted.network,
      transaction: "",
      errorReason: valid.invalidReason ?? "invalid_scheme",
      payer
    };
  }
  try {
    const parseResult = parseErc6492Signature(eip3009Payload.signature);
    const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;
    if (config.deployERC4337WithEIP6492 && factoryAddress && factoryCalldata && !isAddressEqual(factoryAddress, "0x0000000000000000000000000000000000000000")) {
      const bytecode = await signer.getCode({ address: payer });
      if (!bytecode || bytecode === "0x") {
        const deployTx = await signer.sendTransaction({
          to: factoryAddress,
          data: factoryCalldata
        });
        await signer.waitForTransactionReceipt({ hash: deployTx });
      }
    }
    const signatureLength = signature.startsWith("0x") ? signature.length - 2 : signature.length;
    const isECDSA = signatureLength === 130;
    let tx;
    if (isECDSA) {
      const parsedSig = parseSignature(signature);
      tx = await signer.writeContract({
        address: getAddress(requirements.asset),
        abi: eip3009ABI,
        functionName: "transferWithAuthorization",
        args: [
          getAddress(eip3009Payload.authorization.from),
          getAddress(eip3009Payload.authorization.to),
          BigInt(eip3009Payload.authorization.value),
          BigInt(eip3009Payload.authorization.validAfter),
          BigInt(eip3009Payload.authorization.validBefore),
          eip3009Payload.authorization.nonce,
          parsedSig.v || parsedSig.yParity,
          parsedSig.r,
          parsedSig.s
        ]
      });
    } else {
      tx = await signer.writeContract({
        address: getAddress(requirements.asset),
        abi: eip3009ABI,
        functionName: "transferWithAuthorization",
        args: [
          getAddress(eip3009Payload.authorization.from),
          getAddress(eip3009Payload.authorization.to),
          BigInt(eip3009Payload.authorization.value),
          BigInt(eip3009Payload.authorization.validAfter),
          BigInt(eip3009Payload.authorization.validBefore),
          eip3009Payload.authorization.nonce,
          signature
        ]
      });
    }
    const receipt = await signer.waitForTransactionReceipt({ hash: tx });
    if (receipt.status !== "success") {
      return {
        success: false,
        errorReason: "invalid_transaction_state",
        transaction: tx,
        network: payload.accepted.network,
        payer
      };
    }
    return {
      success: true,
      transaction: tx,
      network: payload.accepted.network,
      payer
    };
  } catch {
    return {
      success: false,
      errorReason: "transaction_failed",
      transaction: "",
      network: payload.accepted.network,
      payer
    };
  }
}

// src/exact/facilitator/permit2.ts
import {
  extractEip2612GasSponsoringInfo,
  validateEip2612GasSponsoringInfo,
  extractErc20ApprovalGasSponsoringInfo,
  ERC20_APPROVAL_GAS_SPONSORING
} from "@x402/extensions";
import { getAddress as getAddress3 } from "viem";

// src/exact/facilitator/errors.ts
var ErrPermit2InvalidSignature = "invalid_permit2_signature";
var ErrPermit2InvalidAmount = "permit2_invalid_amount";
var ErrPermit2InvalidDestination = "permit2_invalid_destination";
var ErrPermit2InvalidOwner = "permit2_invalid_owner";
var ErrPermit2PaymentTooEarly = "permit2_payment_too_early";
var ErrPermit2InvalidNonce = "permit2_invalid_nonce";
var ErrPermit2612AmountMismatch = "permit2_2612_amount_mismatch";
var ErrErc20ApprovalInvalidFormat = "invalid_erc20_approval_extension_format";
var ErrErc20ApprovalFromMismatch = "erc20_approval_from_mismatch";
var ErrErc20ApprovalAssetMismatch = "erc20_approval_asset_mismatch";
var ErrErc20ApprovalSpenderNotPermit2 = "erc20_approval_spender_not_permit2";
var ErrErc20ApprovalTxWrongTarget = "erc20_approval_tx_wrong_target";
var ErrErc20ApprovalTxWrongSelector = "erc20_approval_tx_wrong_selector";
var ErrErc20ApprovalTxWrongSpender = "erc20_approval_tx_wrong_spender";
var ErrErc20ApprovalTxInvalidCalldata = "erc20_approval_tx_invalid_calldata";
var ErrErc20ApprovalTxSignerMismatch = "erc20_approval_tx_signer_mismatch";
var ErrErc20ApprovalTxInvalidSignature = "erc20_approval_tx_invalid_signature";
var ErrErc20ApprovalTxParseFailed = "erc20_approval_tx_parse_failed";

// src/exact/facilitator/erc20approval.ts
import {
  getAddress as getAddress2,
  parseTransaction,
  decodeFunctionData,
  recoverTransactionAddress
} from "viem";
import {
  validateErc20ApprovalGasSponsoringInfo
} from "@x402/extensions";
var APPROVE_SELECTOR = "0x095ea7b3";
async function validateErc20ApprovalForPayment(info, payer, tokenAddress) {
  if (!validateErc20ApprovalGasSponsoringInfo(info)) {
    return {
      isValid: false,
      invalidReason: ErrErc20ApprovalInvalidFormat,
      invalidMessage: "ERC-20 approval extension info failed schema validation"
    };
  }
  if (getAddress2(info.from) !== getAddress2(payer)) {
    return {
      isValid: false,
      invalidReason: ErrErc20ApprovalFromMismatch,
      invalidMessage: `Expected from=${payer}, got ${info.from}`
    };
  }
  if (getAddress2(info.asset) !== tokenAddress) {
    return {
      isValid: false,
      invalidReason: ErrErc20ApprovalAssetMismatch,
      invalidMessage: `Expected asset=${tokenAddress}, got ${info.asset}`
    };
  }
  if (getAddress2(info.spender) !== getAddress2(PERMIT2_ADDRESS)) {
    return {
      isValid: false,
      invalidReason: ErrErc20ApprovalSpenderNotPermit2,
      invalidMessage: `Expected spender=${PERMIT2_ADDRESS}, got ${info.spender}`
    };
  }
  try {
    const serializedTx = info.signedTransaction;
    const tx = parseTransaction(serializedTx);
    if (!tx.to || getAddress2(tx.to) !== tokenAddress) {
      return {
        isValid: false,
        invalidReason: ErrErc20ApprovalTxWrongTarget,
        invalidMessage: `Transaction targets ${tx.to ?? "null"}, expected ${tokenAddress}`
      };
    }
    const data = tx.data ?? "0x";
    if (!data.startsWith(APPROVE_SELECTOR)) {
      return {
        isValid: false,
        invalidReason: ErrErc20ApprovalTxWrongSelector,
        invalidMessage: `Transaction calldata does not start with approve() selector ${APPROVE_SELECTOR}`
      };
    }
    try {
      const decoded = decodeFunctionData({
        abi: erc20ApproveAbi,
        data
      });
      const calldataSpender = getAddress2(decoded.args[0]);
      if (calldataSpender !== getAddress2(PERMIT2_ADDRESS)) {
        return {
          isValid: false,
          invalidReason: ErrErc20ApprovalTxWrongSpender,
          invalidMessage: `approve() spender is ${calldataSpender}, expected Permit2 ${PERMIT2_ADDRESS}`
        };
      }
    } catch {
      return {
        isValid: false,
        invalidReason: ErrErc20ApprovalTxInvalidCalldata,
        invalidMessage: "Failed to decode approve() calldata from the signed transaction"
      };
    }
    try {
      const recoveredAddress = await recoverTransactionAddress({
        serializedTransaction: serializedTx
      });
      if (getAddress2(recoveredAddress) !== getAddress2(payer)) {
        return {
          isValid: false,
          invalidReason: ErrErc20ApprovalTxSignerMismatch,
          invalidMessage: `Transaction signed by ${recoveredAddress}, expected payer ${payer}`
        };
      }
    } catch {
      return {
        isValid: false,
        invalidReason: ErrErc20ApprovalTxInvalidSignature,
        invalidMessage: "Failed to recover signer from the signed transaction"
      };
    }
  } catch {
    return {
      isValid: false,
      invalidReason: ErrErc20ApprovalTxParseFailed,
      invalidMessage: "Failed to parse the signed transaction"
    };
  }
  return { isValid: true };
}

// src/exact/facilitator/permit2.ts
async function verifyPermit2(signer, payload, requirements, permit2Payload, context) {
  const payer = permit2Payload.permit2Authorization.from;
  if (payload.accepted.scheme !== "exact" || requirements.scheme !== "exact") {
    return {
      isValid: false,
      invalidReason: "unsupported_scheme",
      payer
    };
  }
  if (payload.accepted.network !== requirements.network) {
    return {
      isValid: false,
      invalidReason: "network_mismatch",
      payer
    };
  }
  const chainId = getEvmChainId(requirements.network);
  const tokenAddress = getAddress3(requirements.asset);
  if (getAddress3(permit2Payload.permit2Authorization.spender) !== getAddress3(x402ExactPermit2ProxyAddress)) {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_spender",
      payer
    };
  }
  if (getAddress3(permit2Payload.permit2Authorization.witness.to) !== getAddress3(requirements.payTo)) {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_recipient_mismatch",
      payer
    };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(permit2Payload.permit2Authorization.deadline) < BigInt(now + 6)) {
    return {
      isValid: false,
      invalidReason: "permit2_deadline_expired",
      payer
    };
  }
  if (BigInt(permit2Payload.permit2Authorization.witness.validAfter) > BigInt(now)) {
    return {
      isValid: false,
      invalidReason: "permit2_not_yet_valid",
      payer
    };
  }
  if (BigInt(permit2Payload.permit2Authorization.permitted.amount) < BigInt(requirements.amount)) {
    return {
      isValid: false,
      invalidReason: "permit2_insufficient_amount",
      payer
    };
  }
  if (getAddress3(permit2Payload.permit2Authorization.permitted.token) !== tokenAddress) {
    return {
      isValid: false,
      invalidReason: "permit2_token_mismatch",
      payer
    };
  }
  const permit2TypedData = {
    types: permit2WitnessTypes,
    primaryType: "PermitWitnessTransferFrom",
    domain: {
      name: "Permit2",
      chainId,
      verifyingContract: PERMIT2_ADDRESS
    },
    message: {
      permitted: {
        token: getAddress3(permit2Payload.permit2Authorization.permitted.token),
        amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
      },
      spender: getAddress3(permit2Payload.permit2Authorization.spender),
      nonce: BigInt(permit2Payload.permit2Authorization.nonce),
      deadline: BigInt(permit2Payload.permit2Authorization.deadline),
      witness: {
        to: getAddress3(permit2Payload.permit2Authorization.witness.to),
        validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter)
      }
    }
  };
  try {
    const isValid = await signer.verifyTypedData({
      address: payer,
      ...permit2TypedData,
      signature: permit2Payload.signature
    });
    if (!isValid) {
      return {
        isValid: false,
        invalidReason: "invalid_permit2_signature",
        payer
      };
    }
  } catch {
    return {
      isValid: false,
      invalidReason: "invalid_permit2_signature",
      payer
    };
  }
  const allowanceResult = await _verifyPermit2Allowance(
    signer,
    payload,
    requirements,
    payer,
    tokenAddress,
    context
  );
  if (allowanceResult) {
    return allowanceResult;
  }
  try {
    const balance = await signer.readContract({
      address: tokenAddress,
      abi: eip3009ABI,
      functionName: "balanceOf",
      args: [payer]
    });
    if (balance < BigInt(requirements.amount)) {
      return {
        isValid: false,
        invalidReason: "insufficient_funds",
        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,
        payer
      };
    }
  } catch {
  }
  return {
    isValid: true,
    invalidReason: void 0,
    payer
  };
}
async function _verifyPermit2Allowance(signer, payload, requirements, payer, tokenAddress, context) {
  try {
    const allowance = await signer.readContract({
      address: tokenAddress,
      abi: erc20AllowanceAbi,
      functionName: "allowance",
      args: [payer, PERMIT2_ADDRESS]
    });
    if (allowance >= BigInt(requirements.amount)) {
      return null;
    }
    const eip2612Info = extractEip2612GasSponsoringInfo(payload);
    if (eip2612Info) {
      const result = validateEip2612PermitForPayment(eip2612Info, payer, tokenAddress);
      if (!result.isValid) {
        return { isValid: false, invalidReason: result.invalidReason, payer };
      }
      return null;
    }
    const erc20GasSponsorshipExtension = context?.getExtension(
      ERC20_APPROVAL_GAS_SPONSORING.key
    );
    if (erc20GasSponsorshipExtension) {
      const erc20Info = extractErc20ApprovalGasSponsoringInfo(payload);
      if (erc20Info) {
        const result = await validateErc20ApprovalForPayment(erc20Info, payer, tokenAddress);
        if (!result.isValid) {
          return { isValid: false, invalidReason: result.invalidReason, payer };
        }
        return null;
      }
    }
    return { isValid: false, invalidReason: "permit2_allowance_required", payer };
  } catch {
    const eip2612Info = extractEip2612GasSponsoringInfo(payload);
    if (eip2612Info) {
      const result = validateEip2612PermitForPayment(eip2612Info, payer, tokenAddress);
      if (!result.isValid) {
        return { isValid: false, invalidReason: result.invalidReason, payer };
      }
    }
    return null;
  }
}
async function settlePermit2(signer, payload, requirements, permit2Payload, context) {
  const payer = permit2Payload.permit2Authorization.from;
  const valid = await verifyPermit2(signer, payload, requirements, permit2Payload, context);
  if (!valid.isValid) {
    return {
      success: false,
      network: payload.accepted.network,
      transaction: "",
      errorReason: valid.invalidReason ?? "invalid_scheme",
      payer
    };
  }
  const eip2612Info = extractEip2612GasSponsoringInfo(payload);
  if (eip2612Info) {
    return _settlePermit2WithEIP2612(signer, payload, permit2Payload, eip2612Info);
  }
  const erc20Info = extractErc20ApprovalGasSponsoringInfo(payload);
  if (erc20Info) {
    const erc20GasSponsorshipExtension = context?.getExtension(
      ERC20_APPROVAL_GAS_SPONSORING.key
    );
    if (erc20GasSponsorshipExtension?.signer) {
      return _settlePermit2WithERC20Approval(
        erc20GasSponsorshipExtension.signer,
        payload,
        permit2Payload,
        erc20Info
      );
    }
  }
  return _settlePermit2Direct(signer, payload, permit2Payload);
}
async function _settlePermit2WithEIP2612(signer, payload, permit2Payload, eip2612Info) {
  const payer = permit2Payload.permit2Authorization.from;
  try {
    const { v, r, s } = splitEip2612Signature(eip2612Info.signature);
    const tx = await signer.writeContract({
      address: x402ExactPermit2ProxyAddress,
      abi: x402ExactPermit2ProxyABI,
      functionName: "settleWithPermit",
      args: [
        {
          value: BigInt(eip2612Info.amount),
          deadline: BigInt(eip2612Info.deadline),
          r,
          s,
          v
        },
        {
          permitted: {
            token: getAddress3(permit2Payload.permit2Authorization.permitted.token),
            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
          },
          nonce: BigInt(permit2Payload.permit2Authorization.nonce),
          deadline: BigInt(permit2Payload.permit2Authorization.deadline)
        },
        getAddress3(payer),
        {
          to: getAddress3(permit2Payload.permit2Authorization.witness.to),
          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter)
        },
        permit2Payload.signature
      ]
    });
    return _waitAndReturn(signer, tx, payload, payer);
  } catch (error) {
    return _mapSettleError(error, payload, payer);
  }
}
async function _settlePermit2WithERC20Approval(extensionSigner, payload, permit2Payload, erc20Info) {
  const payer = permit2Payload.permit2Authorization.from;
  try {
    const approvalTxHash = await extensionSigner.sendRawTransaction({
      serializedTransaction: erc20Info.signedTransaction
    });
    const approvalReceipt = await extensionSigner.waitForTransactionReceipt({
      hash: approvalTxHash
    });
    if (approvalReceipt.status !== "success") {
      return {
        success: false,
        errorReason: "erc20_approval_tx_failed",
        transaction: approvalTxHash,
        network: payload.accepted.network,
        payer
      };
    }
    const tx = await extensionSigner.writeContract({
      address: x402ExactPermit2ProxyAddress,
      abi: x402ExactPermit2ProxyABI,
      functionName: "settle",
      args: [
        {
          permitted: {
            token: getAddress3(permit2Payload.permit2Authorization.permitted.token),
            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
          },
          nonce: BigInt(permit2Payload.permit2Authorization.nonce),
          deadline: BigInt(permit2Payload.permit2Authorization.deadline)
        },
        getAddress3(payer),
        {
          to: getAddress3(permit2Payload.permit2Authorization.witness.to),
          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter)
        },
        permit2Payload.signature
      ]
    });
    return _waitAndReturn(extensionSigner, tx, payload, payer);
  } catch (error) {
    return _mapSettleError(error, payload, payer);
  }
}
async function _settlePermit2Direct(signer, payload, permit2Payload) {
  const payer = permit2Payload.permit2Authorization.from;
  try {
    const tx = await signer.writeContract({
      address: x402ExactPermit2ProxyAddress,
      abi: x402ExactPermit2ProxyABI,
      functionName: "settle",
      args: [
        {
          permitted: {
            token: getAddress3(permit2Payload.permit2Authorization.permitted.token),
            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount)
          },
          nonce: BigInt(permit2Payload.permit2Authorization.nonce),
          deadline: BigInt(permit2Payload.permit2Authorization.deadline)
        },
        getAddress3(payer),
        {
          to: getAddress3(permit2Payload.permit2Authorization.witness.to),
          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter)
        },
        permit2Payload.signature
      ]
    });
    return _waitAndReturn(signer, tx, payload, payer);
  } catch (error) {
    return _mapSettleError(error, payload, payer);
  }
}
async function _waitAndReturn(signer, tx, payload, payer) {
  const receipt = await signer.waitForTransactionReceipt({ hash: tx });
  if (receipt.status !== "success") {
    return {
      success: false,
      errorReason: "invalid_transaction_state",
      transaction: tx,
      network: payload.accepted.network,
      payer
    };
  }
  return {
    success: true,
    transaction: tx,
    network: payload.accepted.network,
    payer
  };
}
function _mapSettleError(error, payload, payer) {
  let errorReason = "transaction_failed";
  if (error instanceof Error) {
    const message = error.message;
    if (message.includes("Permit2612AmountMismatch")) {
      errorReason = ErrPermit2612AmountMismatch;
    } else if (message.includes("InvalidAmount")) {
      errorReason = ErrPermit2InvalidAmount;
    } else if (message.includes("InvalidDestination")) {
      errorReason = ErrPermit2InvalidDestination;
    } else if (message.includes("InvalidOwner")) {
      errorReason = ErrPermit2InvalidOwner;
    } else if (message.includes("PaymentTooEarly")) {
      errorReason = ErrPermit2PaymentTooEarly;
    } else if (message.includes("InvalidSignature") || message.includes("SignatureExpired")) {
      errorReason = ErrPermit2InvalidSignature;
    } else if (message.includes("InvalidNonce")) {
      errorReason = ErrPermit2InvalidNonce;
    } else {
      errorReason = `transaction_failed: ${message.slice(0, 500)}`;
    }
  }
  return {
    success: false,
    errorReason,
    transaction: "",
    network: payload.accepted.network,
    payer
  };
}
function validateEip2612PermitForPayment(info, payer, tokenAddress) {
  if (!validateEip2612GasSponsoringInfo(info)) {
    return { isValid: false, invalidReason: "invalid_eip2612_extension_format" };
  }
  if (getAddress3(info.from) !== getAddress3(payer)) {
    return { isValid: false, invalidReason: "eip2612_from_mismatch" };
  }
  if (getAddress3(info.asset) !== tokenAddress) {
    return { isValid: false, invalidReason: "eip2612_asset_mismatch" };
  }
  if (getAddress3(info.spender) !== getAddress3(PERMIT2_ADDRESS)) {
    return { isValid: false, invalidReason: "eip2612_spender_not_permit2" };
  }
  const now = Math.floor(Date.now() / 1e3);
  if (BigInt(info.deadline) < BigInt(now + 6)) {
    return { isValid: false, invalidReason: "eip2612_deadline_expired" };
  }
  return { isValid: true };
}
function splitEip2612Signature(signature) {
  const sig = signature.startsWith("0x") ? signature.slice(2) : signature;
  if (sig.length !== 130) {
    throw new Error(
      `invalid EIP-2612 signature length: expected 65 bytes (130 hex chars), got ${sig.length / 2} bytes`
    );
  }
  const r = `0x${sig.slice(0, 64)}`;
  const s = `0x${sig.slice(64, 128)}`;
  const v = parseInt(sig.slice(128, 130), 16);
  return { v, r, s };
}

// src/exact/facilitator/scheme.ts
var ExactEvmScheme = class {
  /**
   * Creates a new ExactEvmScheme facilitator instance.
   *
   * @param signer - The EVM signer for facilitator operations
   * @param config - Optional configuration
   */
  constructor(signer, config) {
    this.signer = signer;
    this.scheme = "exact";
    this.caipFamily = "eip155:*";
    this.config = {
      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false
    };
  }
  /**
   * Returns undefined â€” EVM has no mechanism-specific extra data.
   *
   * @param _ - The network identifier (unused)
   * @returns undefined
   */
  getExtra(_) {
    return void 0;
  }
  /**
   * Returns facilitator wallet addresses for the supported response.
   *
   * @param _ - The network identifier (unused, addresses are network-agnostic)
   * @returns Array of facilitator wallet addresses
   */
  getSigners(_) {
    return [...this.signer.getAddresses()];
  }
  /**
   * Verifies a payment payload. Routes to Permit2 or EIP-3009 based on payload type.
   *
   * @param payload - The payment payload to verify
   * @param requirements - The payment requirements
   * @param context - Optional facilitator context for extension capabilities
   * @returns Promise resolving to verification response
   */
  async verify(payload, requirements, context) {
    const rawPayload = payload.payload;
    if (isPermit2Payload(rawPayload)) {
      return verifyPermit2(this.signer, payload, requirements, rawPayload, context);
    }
    const eip3009Payload = rawPayload;
    return verifyEIP3009(this.signer, payload, requirements, eip3009Payload);
  }
  /**
   * Settles a payment. Routes to Permit2 or EIP-3009 based on payload type.
   *
   * @param payload - The payment payload to settle
   * @param requirements - The payment requirements
   * @param context - Optional facilitator context for extension capabilities
   * @returns Promise resolving to settlement response
   */
  async settle(payload, requirements, context) {
    const rawPayload = payload.payload;
    if (isPermit2Payload(rawPayload)) {
      return settlePermit2(this.signer, payload, requirements, rawPayload, context);
    }
    const eip3009Payload = rawPayload;
    return settleEIP3009(this.signer, payload, requirements, eip3009Payload, this.config);
  }
};

// src/exact/facilitator/register.ts
function registerExactEvmScheme(facilitator, config) {
  facilitator.register(
    config.networks,
    new ExactEvmScheme(config.signer, {
      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492
    })
  );
  facilitator.registerV1(
    NETWORKS,
    new ExactEvmSchemeV1(config.signer, {
      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492
    })
  );
  return facilitator;
}
export {
  ExactEvmScheme,
  registerExactEvmScheme
};
//# sourceMappingURL=index.mjs.map