import {
  DEFAULT_MAX_FEE_PER_GAS,
  DEFAULT_MAX_PRIORITY_FEE_PER_GAS,
  ERC20_APPROVE_GAS_LIMIT,
  ExactEvmSchemeV12 as ExactEvmSchemeV1,
  NETWORKS,
  PERMIT2_ADDRESS,
  authorizationTypes,
  createNonce,
  createPermit2Nonce,
  eip2612NoncesAbi,
  eip2612PermitTypes,
  erc20AllowanceAbi,
  erc20ApproveAbi,
  getEvmChainId,
  permit2WitnessTypes,
  x402ExactPermit2ProxyAddress
} from "./chunk-7KHQD5KT.mjs";

// src/exact/client/scheme.ts
import { EIP2612_GAS_SPONSORING, ERC20_APPROVAL_GAS_SPONSORING } from "@x402/extensions";
import { getAddress as getAddress5 } from "viem";

// src/exact/client/eip3009.ts
import { getAddress } from "viem";
async function createEIP3009Payload(signer, x402Version, paymentRequirements) {
  const nonce = createNonce();
  const now = Math.floor(Date.now() / 1e3);
  const authorization = {
    from: signer.address,
    to: getAddress(paymentRequirements.payTo),
    value: paymentRequirements.amount,
    validAfter: (now - 600).toString(),
    validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),
    nonce
  };
  const signature = await signEIP3009Authorization(signer, authorization, paymentRequirements);
  const payload = {
    authorization,
    signature
  };
  return {
    x402Version,
    payload
  };
}
async function signEIP3009Authorization(signer, authorization, requirements) {
  const chainId = getEvmChainId(requirements.network);
  if (!requirements.extra?.name || !requirements.extra?.version) {
    throw new Error(
      `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`
    );
  }
  const { name, version } = requirements.extra;
  const domain = {
    name,
    version,
    chainId,
    verifyingContract: getAddress(requirements.asset)
  };
  const message = {
    from: getAddress(authorization.from),
    to: getAddress(authorization.to),
    value: BigInt(authorization.value),
    validAfter: BigInt(authorization.validAfter),
    validBefore: BigInt(authorization.validBefore),
    nonce: authorization.nonce
  };
  return await signer.signTypedData({
    domain,
    types: authorizationTypes,
    primaryType: "TransferWithAuthorization",
    message
  });
}

// src/exact/client/permit2.ts
import { encodeFunctionData, getAddress as getAddress2 } from "viem";
var MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
async function createPermit2Payload(signer, x402Version, paymentRequirements) {
  const now = Math.floor(Date.now() / 1e3);
  const nonce = createPermit2Nonce();
  const validAfter = (now - 600).toString();
  const deadline = (now + paymentRequirements.maxTimeoutSeconds).toString();
  const permit2Authorization = {
    from: signer.address,
    permitted: {
      token: getAddress2(paymentRequirements.asset),
      amount: paymentRequirements.amount
    },
    spender: x402ExactPermit2ProxyAddress,
    nonce,
    deadline,
    witness: {
      to: getAddress2(paymentRequirements.payTo),
      validAfter
    }
  };
  const signature = await signPermit2Authorization(
    signer,
    permit2Authorization,
    paymentRequirements
  );
  const payload = {
    signature,
    permit2Authorization
  };
  return {
    x402Version,
    payload
  };
}
async function signPermit2Authorization(signer, permit2Authorization, requirements) {
  const chainId = getEvmChainId(requirements.network);
  const domain = {
    name: "Permit2",
    chainId,
    verifyingContract: PERMIT2_ADDRESS
  };
  const message = {
    permitted: {
      token: getAddress2(permit2Authorization.permitted.token),
      amount: BigInt(permit2Authorization.permitted.amount)
    },
    spender: getAddress2(permit2Authorization.spender),
    nonce: BigInt(permit2Authorization.nonce),
    deadline: BigInt(permit2Authorization.deadline),
    witness: {
      to: getAddress2(permit2Authorization.witness.to),
      validAfter: BigInt(permit2Authorization.witness.validAfter)
    }
  };
  return await signer.signTypedData({
    domain,
    types: permit2WitnessTypes,
    primaryType: "PermitWitnessTransferFrom",
    message
  });
}
function createPermit2ApprovalTx(tokenAddress) {
  const data = encodeFunctionData({
    abi: erc20ApproveAbi,
    functionName: "approve",
    args: [PERMIT2_ADDRESS, MAX_UINT256]
  });
  return {
    to: getAddress2(tokenAddress),
    data
  };
}
function getPermit2AllowanceReadParams(params) {
  return {
    address: getAddress2(params.tokenAddress),
    abi: erc20AllowanceAbi,
    functionName: "allowance",
    args: [getAddress2(params.ownerAddress), PERMIT2_ADDRESS]
  };
}

// src/exact/client/eip2612.ts
import { getAddress as getAddress3 } from "viem";
async function signEip2612Permit(signer, tokenAddress, tokenName, tokenVersion, chainId, deadline, permittedAmount) {
  const owner = signer.address;
  const spender = getAddress3(PERMIT2_ADDRESS);
  const nonce = await signer.readContract({
    address: tokenAddress,
    abi: eip2612NoncesAbi,
    functionName: "nonces",
    args: [owner]
  });
  const domain = {
    name: tokenName,
    version: tokenVersion,
    chainId,
    verifyingContract: tokenAddress
  };
  const approvalAmount = BigInt(permittedAmount);
  const message = {
    owner,
    spender,
    value: approvalAmount,
    nonce,
    deadline: BigInt(deadline)
  };
  const signature = await signer.signTypedData({
    domain,
    types: eip2612PermitTypes,
    primaryType: "Permit",
    message
  });
  return {
    from: owner,
    asset: tokenAddress,
    spender,
    amount: approvalAmount.toString(),
    nonce: nonce.toString(),
    deadline,
    signature,
    version: "1"
  };
}

// src/exact/client/erc20approval.ts
import { encodeFunctionData as encodeFunctionData2, getAddress as getAddress4, maxUint256 } from "viem";
import {
  ERC20_APPROVAL_GAS_SPONSORING_VERSION
} from "@x402/extensions";
async function signErc20ApprovalTransaction(signer, tokenAddress, chainId) {
  const from = signer.address;
  const spender = getAddress4(PERMIT2_ADDRESS);
  const data = encodeFunctionData2({
    abi: erc20ApproveAbi,
    functionName: "approve",
    args: [spender, maxUint256]
  });
  const nonce = await signer.getTransactionCount({ address: from });
  let maxFeePerGas;
  let maxPriorityFeePerGas;
  try {
    const fees = await signer.estimateFeesPerGas();
    maxFeePerGas = fees.maxFeePerGas;
    maxPriorityFeePerGas = fees.maxPriorityFeePerGas;
  } catch {
    maxFeePerGas = DEFAULT_MAX_FEE_PER_GAS;
    maxPriorityFeePerGas = DEFAULT_MAX_PRIORITY_FEE_PER_GAS;
  }
  const signedTransaction = await signer.signTransaction({
    to: tokenAddress,
    data,
    nonce,
    gas: ERC20_APPROVE_GAS_LIMIT,
    maxFeePerGas,
    maxPriorityFeePerGas,
    chainId
  });
  return {
    from,
    asset: tokenAddress,
    spender,
    amount: maxUint256.toString(),
    signedTransaction,
    version: ERC20_APPROVAL_GAS_SPONSORING_VERSION
  };
}

// src/exact/client/scheme.ts
var ExactEvmScheme = class {
  /**
   * Creates a new ExactEvmClient instance.
   *
   * @param signer - The EVM signer for client operations.
   *   Must support `readContract` for EIP-2612 gas sponsoring.
   *   Use `createWalletClient(...).extend(publicActions)` or `toClientEvmSigner(account, publicClient)`.
   */
  constructor(signer) {
    this.signer = signer;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme.
   * Routes to EIP-3009 or Permit2 based on requirements.extra.assetTransferMethod.
   *
   * For Permit2 flows, if the server advertises `eip2612GasSponsoring` and the
   * signer supports `readContract`, automatically signs an EIP-2612 permit
   * when Permit2 allowance is insufficient.
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @param context - Optional context with server-declared extensions
   * @returns Promise resolving to a payment payload result (with optional extensions)
   */
  async createPaymentPayload(x402Version, paymentRequirements, context) {
    const assetTransferMethod = paymentRequirements.extra?.assetTransferMethod ?? "eip3009";
    if (assetTransferMethod === "permit2") {
      const result = await createPermit2Payload(this.signer, x402Version, paymentRequirements);
      const eip2612Extensions = await this.trySignEip2612Permit(
        paymentRequirements,
        result,
        context
      );
      if (eip2612Extensions) {
        return {
          ...result,
          extensions: eip2612Extensions
        };
      }
      const erc20Extensions = await this.trySignErc20Approval(paymentRequirements, result, context);
      if (erc20Extensions) {
        return {
          ...result,
          extensions: erc20Extensions
        };
      }
      return result;
    }
    return createEIP3009Payload(this.signer, x402Version, paymentRequirements);
  }
  /**
   * Attempts to sign an EIP-2612 permit for gasless Permit2 approval.
   *
   * Returns extension data if:
   * 1. Server advertises eip2612GasSponsoring
   * 2. Signer has readContract capability
   * 3. Current Permit2 allowance is insufficient
   *
   * Returns undefined if the extension should not be used.
   *
   * @param requirements - The payment requirements from the server
   * @param result - The payment payload result from the scheme
   * @param context - Optional context containing server extensions and metadata
   * @returns Extension data for EIP-2612 gas sponsoring, or undefined if not applicable
   */
  async trySignEip2612Permit(requirements, result, context) {
    if (!context?.extensions?.[EIP2612_GAS_SPONSORING.key]) {
      return void 0;
    }
    const tokenName = requirements.extra?.name;
    const tokenVersion = requirements.extra?.version;
    if (!tokenName || !tokenVersion) {
      return void 0;
    }
    const chainId = getEvmChainId(requirements.network);
    const tokenAddress = getAddress5(requirements.asset);
    try {
      const allowance = await this.signer.readContract({
        address: tokenAddress,
        abi: erc20AllowanceAbi,
        functionName: "allowance",
        args: [this.signer.address, PERMIT2_ADDRESS]
      });
      if (allowance >= BigInt(requirements.amount)) {
        return void 0;
      }
    } catch {
    }
    const permit2Auth = result.payload?.permit2Authorization;
    const deadline = permit2Auth?.deadline ?? Math.floor(Date.now() / 1e3 + requirements.maxTimeoutSeconds).toString();
    const info = await signEip2612Permit(
      this.signer,
      tokenAddress,
      tokenName,
      tokenVersion,
      chainId,
      deadline,
      requirements.amount
    );
    return {
      [EIP2612_GAS_SPONSORING.key]: { info }
    };
  }
  /**
   * Attempts to sign an ERC-20 approval transaction for gasless Permit2 approval.
   *
   * This is the fallback path when the token does not support EIP-2612. The client
   * signs (but does not broadcast) a raw `approve(Permit2, MaxUint256)` transaction.
   * The facilitator broadcasts it atomically before settling.
   *
   * Returns extension data if:
   * 1. Server advertises erc20ApprovalGasSponsoring
   * 2. Signer has signTransaction + getTransactionCount capabilities
   * 3. Current Permit2 allowance is insufficient
   *
   * Returns undefined if the extension should not be used.
   *
   * @param requirements - The payment requirements from the server
   * @param _result - The payment payload result from the scheme (unused)
   * @param context - Optional context containing server extensions and metadata
   * @returns Extension data for ERC-20 approval gas sponsoring, or undefined if not applicable
   */
  async trySignErc20Approval(requirements, _result, context) {
    if (!context?.extensions?.[ERC20_APPROVAL_GAS_SPONSORING.key]) {
      return void 0;
    }
    if (!this.signer.signTransaction || !this.signer.getTransactionCount) {
      return void 0;
    }
    const chainId = getEvmChainId(requirements.network);
    const tokenAddress = getAddress5(requirements.asset);
    try {
      const allowance = await this.signer.readContract({
        address: tokenAddress,
        abi: erc20AllowanceAbi,
        functionName: "allowance",
        args: [this.signer.address, PERMIT2_ADDRESS]
      });
      if (allowance >= BigInt(requirements.amount)) {
        return void 0;
      }
    } catch {
    }
    const info = await signErc20ApprovalTransaction(this.signer, tokenAddress, chainId);
    return {
      [ERC20_APPROVAL_GAS_SPONSORING.key]: { info }
    };
  }
};

// src/exact/client/register.ts
function registerExactEvmScheme(client, config) {
  const evmScheme = new ExactEvmScheme(config.signer);
  if (config.networks && config.networks.length > 0) {
    config.networks.forEach((network) => {
      client.register(network, evmScheme);
    });
  } else {
    client.register("eip155:*", evmScheme);
  }
  NETWORKS.forEach((network) => {
    client.registerV1(network, new ExactEvmSchemeV1(config.signer));
  });
  if (config.policies) {
    config.policies.forEach((policy) => {
      client.registerPolicy(policy);
    });
  }
  return client;
}

export {
  createPermit2ApprovalTx,
  getPermit2AllowanceReadParams,
  ExactEvmScheme,
  registerExactEvmScheme
};
//# sourceMappingURL=chunk-GY6X5A3G.mjs.map