import { SchemeNetworkClient, PaymentRequirements, PaymentPayloadContext, PaymentPayloadResult } from '@x402/core/types';
import { C as ClientEvmSigner } from './signer-DC81R8wQ.js';

/**
 * EVM client implementation for the Exact payment scheme.
 * Supports both EIP-3009 (transferWithAuthorization) and Permit2 flows.
 *
 * Routes to the appropriate authorization method based on
 * `requirements.extra.assetTransferMethod`. Defaults to EIP-3009
 * for backward compatibility with older facilitators.
 *
 * When the server advertises `eip2612GasSponsoring` and the asset transfer
 * method is `permit2`, the scheme automatically signs an EIP-2612 permit
 * if the user lacks Permit2 approval. This requires `readContract` on the signer.
 */
declare class ExactEvmScheme implements SchemeNetworkClient {
    private readonly signer;
    readonly scheme = "exact";
    /**
     * Creates a new ExactEvmClient instance.
     *
     * @param signer - The EVM signer for client operations.
     *   Must support `readContract` for EIP-2612 gas sponsoring.
     *   Use `createWalletClient(...).extend(publicActions)` or `toClientEvmSigner(account, publicClient)`.
     */
    constructor(signer: ClientEvmSigner);
    /**
     * Creates a payment payload for the Exact scheme.
     * Routes to EIP-3009 or Permit2 based on requirements.extra.assetTransferMethod.
     *
     * For Permit2 flows, if the server advertises `eip2612GasSponsoring` and the
     * signer supports `readContract`, automatically signs an EIP-2612 permit
     * when Permit2 allowance is insufficient.
     *
     * @param x402Version - The x402 protocol version
     * @param paymentRequirements - The payment requirements
     * @param context - Optional context with server-declared extensions
     * @returns Promise resolving to a payment payload result (with optional extensions)
     */
    createPaymentPayload(x402Version: number, paymentRequirements: PaymentRequirements, context?: PaymentPayloadContext): Promise<PaymentPayloadResult>;
    /**
     * Attempts to sign an EIP-2612 permit for gasless Permit2 approval.
     *
     * Returns extension data if:
     * 1. Server advertises eip2612GasSponsoring
     * 2. Signer has readContract capability
     * 3. Current Permit2 allowance is insufficient
     *
     * Returns undefined if the extension should not be used.
     *
     * @param requirements - The payment requirements from the server
     * @param result - The payment payload result from the scheme
     * @param context - Optional context containing server extensions and metadata
     * @returns Extension data for EIP-2612 gas sponsoring, or undefined if not applicable
     */
    private trySignEip2612Permit;
    /**
     * Attempts to sign an ERC-20 approval transaction for gasless Permit2 approval.
     *
     * This is the fallback path when the token does not support EIP-2612. The client
     * signs (but does not broadcast) a raw `approve(Permit2, MaxUint256)` transaction.
     * The facilitator broadcasts it atomically before settling.
     *
     * Returns extension data if:
     * 1. Server advertises erc20ApprovalGasSponsoring
     * 2. Signer has signTransaction + getTransactionCount capabilities
     * 3. Current Permit2 allowance is insufficient
     *
     * Returns undefined if the extension should not be used.
     *
     * @param requirements - The payment requirements from the server
     * @param _result - The payment payload result from the scheme (unused)
     * @param context - Optional context containing server extensions and metadata
     * @returns Extension data for ERC-20 approval gas sponsoring, or undefined if not applicable
     */
    private trySignErc20Approval;
}

declare const authorizationTypes: {
    readonly TransferWithAuthorization: readonly [{
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly name: "validAfter";
        readonly type: "uint256";
    }, {
        readonly name: "validBefore";
        readonly type: "uint256";
    }, {
        readonly name: "nonce";
        readonly type: "bytes32";
    }];
};
/**
 * Permit2 EIP-712 types for signing PermitWitnessTransferFrom.
 * Must match the exact format expected by the Permit2 contract.
 * Note: Types must be in ALPHABETICAL order after the primary type (TokenPermissions < Witness).
 */
declare const permit2WitnessTypes: {
    readonly PermitWitnessTransferFrom: readonly [{
        readonly name: "permitted";
        readonly type: "TokenPermissions";
    }, {
        readonly name: "spender";
        readonly type: "address";
    }, {
        readonly name: "nonce";
        readonly type: "uint256";
    }, {
        readonly name: "deadline";
        readonly type: "uint256";
    }, {
        readonly name: "witness";
        readonly type: "Witness";
    }];
    readonly TokenPermissions: readonly [{
        readonly name: "token";
        readonly type: "address";
    }, {
        readonly name: "amount";
        readonly type: "uint256";
    }];
    readonly Witness: readonly [{
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "validAfter";
        readonly type: "uint256";
    }];
};
declare const eip3009ABI: readonly [{
    readonly inputs: readonly [{
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly name: "validAfter";
        readonly type: "uint256";
    }, {
        readonly name: "validBefore";
        readonly type: "uint256";
    }, {
        readonly name: "nonce";
        readonly type: "bytes32";
    }, {
        readonly name: "v";
        readonly type: "uint8";
    }, {
        readonly name: "r";
        readonly type: "bytes32";
    }, {
        readonly name: "s";
        readonly type: "bytes32";
    }];
    readonly name: "transferWithAuthorization";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly name: "validAfter";
        readonly type: "uint256";
    }, {
        readonly name: "validBefore";
        readonly type: "uint256";
    }, {
        readonly name: "nonce";
        readonly type: "bytes32";
    }, {
        readonly name: "signature";
        readonly type: "bytes";
    }];
    readonly name: "transferWithAuthorization";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly name: "account";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "version";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}];
/** ERC-20 allowance(address,address) ABI for checking spender approval. */
declare const erc20AllowanceAbi: readonly [{
    readonly type: "function";
    readonly name: "allowance";
    readonly inputs: readonly [{
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly name: "spender";
        readonly type: "address";
    }];
    readonly outputs: readonly [{
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
}];
/**
 * Canonical Permit2 contract address.
 * Same address on all EVM chains via CREATE2 deployment.
 *
 * @see https://github.com/Uniswap/permit2
 */
declare const PERMIT2_ADDRESS: "0x000000000022D473030F116dDEE9F6B43aC78BA3";
/**
 * x402ExactPermit2Proxy contract address.
 * Vanity address: 0x4020...0001 for easy recognition.
 * This address is deterministic based on:
 * - Arachnid's deterministic deployer (0x4e59b44847b379578588920cA78FbF26c0B4956C)
 * - Vanity-mined salt for prefix 0x4020 and suffix 0001
 * - Contract bytecode + constructor args (PERMIT2_ADDRESS)
 */
declare const x402ExactPermit2ProxyAddress: "0x402085c248EeA27D92E8b30b2C58ed07f9E20001";
/**
 * x402UptoPermit2Proxy contract address.
 * Vanity address: 0x4020...0002 for easy recognition.
 * This address is deterministic based on:
 * - Arachnid's deterministic deployer (0x4e59b44847b379578588920cA78FbF26c0B4956C)
 * - Vanity-mined salt for prefix 0x4020 and suffix 0002
 * - Contract bytecode + constructor args (PERMIT2_ADDRESS)
 */
declare const x402UptoPermit2ProxyAddress: "0x402039b3d6E6BEC5A02c2C9fd937ac17A6940002";
/**
 * x402ExactPermit2Proxy ABI - settle function for exact payment scheme.
 */
declare const x402ExactPermit2ProxyABI: readonly [{
    readonly type: "function";
    readonly name: "PERMIT2";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "address";
        readonly internalType: "contract ISignatureTransfer";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "WITNESS_TYPEHASH";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "bytes32";
        readonly internalType: "bytes32";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "WITNESS_TYPE_STRING";
    readonly inputs: readonly [];
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
        readonly internalType: "string";
    }];
    readonly stateMutability: "view";
}, {
    readonly type: "function";
    readonly name: "settle";
    readonly inputs: readonly [{
        readonly name: "permit";
        readonly type: "tuple";
        readonly internalType: "struct ISignatureTransfer.PermitTransferFrom";
        readonly components: readonly [{
            readonly name: "permitted";
            readonly type: "tuple";
            readonly internalType: "struct ISignatureTransfer.TokenPermissions";
            readonly components: readonly [{
                readonly name: "token";
                readonly type: "address";
                readonly internalType: "address";
            }, {
                readonly name: "amount";
                readonly type: "uint256";
                readonly internalType: "uint256";
            }];
        }, {
            readonly name: "nonce";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }, {
            readonly name: "deadline";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }];
    }, {
        readonly name: "owner";
        readonly type: "address";
        readonly internalType: "address";
    }, {
        readonly name: "witness";
        readonly type: "tuple";
        readonly internalType: "struct x402ExactPermit2Proxy.Witness";
        readonly components: readonly [{
            readonly name: "to";
            readonly type: "address";
            readonly internalType: "address";
        }, {
            readonly name: "validAfter";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }];
    }, {
        readonly name: "signature";
        readonly type: "bytes";
        readonly internalType: "bytes";
    }];
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
}, {
    readonly type: "function";
    readonly name: "settleWithPermit";
    readonly inputs: readonly [{
        readonly name: "permit2612";
        readonly type: "tuple";
        readonly internalType: "struct x402ExactPermit2Proxy.EIP2612Permit";
        readonly components: readonly [{
            readonly name: "value";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }, {
            readonly name: "deadline";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }, {
            readonly name: "r";
            readonly type: "bytes32";
            readonly internalType: "bytes32";
        }, {
            readonly name: "s";
            readonly type: "bytes32";
            readonly internalType: "bytes32";
        }, {
            readonly name: "v";
            readonly type: "uint8";
            readonly internalType: "uint8";
        }];
    }, {
        readonly name: "permit";
        readonly type: "tuple";
        readonly internalType: "struct ISignatureTransfer.PermitTransferFrom";
        readonly components: readonly [{
            readonly name: "permitted";
            readonly type: "tuple";
            readonly internalType: "struct ISignatureTransfer.TokenPermissions";
            readonly components: readonly [{
                readonly name: "token";
                readonly type: "address";
                readonly internalType: "address";
            }, {
                readonly name: "amount";
                readonly type: "uint256";
                readonly internalType: "uint256";
            }];
        }, {
            readonly name: "nonce";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }, {
            readonly name: "deadline";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }];
    }, {
        readonly name: "owner";
        readonly type: "address";
        readonly internalType: "address";
    }, {
        readonly name: "witness";
        readonly type: "tuple";
        readonly internalType: "struct x402ExactPermit2Proxy.Witness";
        readonly components: readonly [{
            readonly name: "to";
            readonly type: "address";
            readonly internalType: "address";
        }, {
            readonly name: "validAfter";
            readonly type: "uint256";
            readonly internalType: "uint256";
        }];
    }, {
        readonly name: "signature";
        readonly type: "bytes";
        readonly internalType: "bytes";
    }];
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
}, {
    readonly type: "event";
    readonly name: "Settled";
    readonly inputs: readonly [];
    readonly anonymous: false;
}, {
    readonly type: "event";
    readonly name: "SettledWithPermit";
    readonly inputs: readonly [];
    readonly anonymous: false;
}, {
    readonly type: "error";
    readonly name: "InvalidAmount";
    readonly inputs: readonly [];
}, {
    readonly type: "error";
    readonly name: "InvalidDestination";
    readonly inputs: readonly [];
}, {
    readonly type: "error";
    readonly name: "InvalidOwner";
    readonly inputs: readonly [];
}, {
    readonly type: "error";
    readonly name: "InvalidPermit2Address";
    readonly inputs: readonly [];
}, {
    readonly type: "error";
    readonly name: "PaymentTooEarly";
    readonly inputs: readonly [];
}, {
    readonly type: "error";
    readonly name: "Permit2612AmountMismatch";
    readonly inputs: readonly [];
}, {
    readonly type: "error";
    readonly name: "ReentrancyGuardReentrantCall";
    readonly inputs: readonly [];
}];

/**
 * Creates transaction data to approve Permit2 to spend tokens.
 * The user sends this transaction (paying gas) before using Permit2 flow.
 *
 * @param tokenAddress - The ERC20 token contract address
 * @returns Transaction data to send for approval
 *
 * @example
 * ```typescript
 * const tx = createPermit2ApprovalTx("0x...");
 * await walletClient.sendTransaction({
 *   to: tx.to,
 *   data: tx.data,
 * });
 * ```
 */
declare function createPermit2ApprovalTx(tokenAddress: `0x${string}`): {
    to: `0x${string}`;
    data: `0x${string}`;
};
/**
 * Parameters for checking Permit2 allowance.
 * Application provides these to check if approval is needed.
 */
interface Permit2AllowanceParams {
    tokenAddress: `0x${string}`;
    ownerAddress: `0x${string}`;
}
/**
 * Returns contract read parameters for checking Permit2 allowance.
 * Use with a public client to check if the user has approved Permit2.
 *
 * @param params - The allowance check parameters
 * @returns Contract read parameters for checking allowance
 *
 * @example
 * ```typescript
 * const readParams = getPermit2AllowanceReadParams({
 *   tokenAddress: "0x...",
 *   ownerAddress: "0x...",
 * });
 *
 * const allowance = await publicClient.readContract(readParams);
 * const needsApproval = allowance < requiredAmount;
 * ```
 */
declare function getPermit2AllowanceReadParams(params: Permit2AllowanceParams): {
    address: `0x${string}`;
    abi: typeof erc20AllowanceAbi;
    functionName: "allowance";
    args: [`0x${string}`, `0x${string}`];
};

export { ExactEvmScheme as E, PERMIT2_ADDRESS as P, type Permit2AllowanceParams as a, authorizationTypes as b, createPermit2ApprovalTx as c, erc20AllowanceAbi as d, eip3009ABI as e, x402ExactPermit2ProxyAddress as f, getPermit2AllowanceReadParams as g, x402UptoPermit2ProxyAddress as h, permit2WitnessTypes as p, x402ExactPermit2ProxyABI as x };
