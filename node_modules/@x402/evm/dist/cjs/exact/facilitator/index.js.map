{"version":3,"sources":["../../../../src/exact/facilitator/index.ts","../../../../src/types.ts","../../../../src/exact/facilitator/eip3009.ts","../../../../src/constants.ts","../../../../src/utils.ts","../../../../src/exact/facilitator/permit2.ts","../../../../src/exact/facilitator/errors.ts","../../../../src/exact/facilitator/erc20approval.ts","../../../../src/exact/facilitator/scheme.ts","../../../../src/exact/v1/facilitator/scheme.ts","../../../../src/exact/v1/client/scheme.ts","../../../../src/v1/index.ts","../../../../src/exact/facilitator/register.ts"],"sourcesContent":["export { ExactEvmScheme } from \"./scheme\";\nexport type { ExactEvmSchemeConfig } from \"./scheme\";\nexport { registerExactEvmScheme } from \"./register\";\nexport type { EvmFacilitatorConfig } from \"./register\";\n","/**\n * Asset transfer methods for the exact EVM scheme.\n * - eip3009: Uses transferWithAuthorization (USDC, etc.) - recommended for compatible tokens\n * - permit2: Uses Permit2 + x402Permit2Proxy - universal fallback for any ERC-20\n */\nexport type AssetTransferMethod = \"eip3009\" | \"permit2\";\n\n/**\n * EIP-3009 payload for tokens with native transferWithAuthorization support.\n */\nexport type ExactEIP3009Payload = {\n  signature?: `0x${string}`;\n  authorization: {\n    from: `0x${string}`;\n    to: `0x${string}`;\n    value: string;\n    validAfter: string;\n    validBefore: string;\n    nonce: `0x${string}`;\n  };\n};\n\n/**\n * Permit2 witness data structure.\n * Matches the Witness struct in x402Permit2Proxy contract.\n * Note: Upper time bound is enforced by Permit2's `deadline` field, not a witness field.\n */\nexport type Permit2Witness = {\n  to: `0x${string}`;\n  validAfter: string;\n};\n\n/**\n * Permit2 authorization parameters.\n * Used to reconstruct the signed message for verification.\n */\nexport type Permit2Authorization = {\n  permitted: {\n    token: `0x${string}`;\n    amount: string;\n  };\n  spender: `0x${string}`;\n  nonce: string;\n  deadline: string;\n  witness: Permit2Witness;\n};\n\n/**\n * Permit2 payload for tokens using the Permit2 + x402Permit2Proxy flow.\n */\nexport type ExactPermit2Payload = {\n  signature: `0x${string}`;\n  permit2Authorization: Permit2Authorization & {\n    from: `0x${string}`;\n  };\n};\n\nexport type ExactEvmPayloadV1 = ExactEIP3009Payload;\n\nexport type ExactEvmPayloadV2 = ExactEIP3009Payload | ExactPermit2Payload;\n\n/**\n * Type guard to check if a payload is a Permit2 payload.\n * Permit2 payloads have a `permit2Authorization` field.\n *\n * @param payload - The payload to check.\n * @returns True if the payload is a Permit2 payload, false otherwise.\n */\nexport function isPermit2Payload(payload: ExactEvmPayloadV2): payload is ExactPermit2Payload {\n  return \"permit2Authorization\" in payload;\n}\n\n/**\n * Type guard to check if a payload is an EIP-3009 payload.\n * EIP-3009 payloads have an `authorization` field.\n *\n * @param payload - The payload to check.\n * @returns True if the payload is an EIP-3009 payload, false otherwise.\n */\nexport function isEIP3009Payload(payload: ExactEvmPayloadV2): payload is ExactEIP3009Payload {\n  return \"authorization\" in payload;\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../constants\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { getEvmChainId } from \"../../utils\";\nimport { ExactEIP3009Payload } from \"../../types\";\n\nexport interface EIP3009FacilitatorConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492: boolean;\n}\n\n/**\n * Verifies an EIP-3009 payment payload.\n *\n * @param signer - The facilitator signer for contract reads\n * @param payload - The payment payload to verify\n * @param requirements - The payment requirements\n * @param eip3009Payload - The EIP-3009 specific payload\n * @returns Promise resolving to verification response\n */\nexport async function verifyEIP3009(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  eip3009Payload: ExactEIP3009Payload,\n): Promise<VerifyResponse> {\n  const payer = eip3009Payload.authorization.from;\n\n  // Verify scheme matches\n  if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n    return {\n      isValid: false,\n      invalidReason: \"unsupported_scheme\",\n      payer,\n    };\n  }\n\n  // Get chain configuration\n  if (!requirements.extra?.name || !requirements.extra?.version) {\n    return {\n      isValid: false,\n      invalidReason: \"missing_eip712_domain\",\n      payer,\n    };\n  }\n\n  const { name, version } = requirements.extra;\n  const erc20Address = getAddress(requirements.asset);\n\n  // Verify network matches\n  if (payload.accepted.network !== requirements.network) {\n    return {\n      isValid: false,\n      invalidReason: \"network_mismatch\",\n      payer,\n    };\n  }\n\n  // Build typed data for signature verification\n  const permitTypedData = {\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\" as const,\n    domain: {\n      name,\n      version,\n      chainId: getEvmChainId(requirements.network),\n      verifyingContract: erc20Address,\n    },\n    message: {\n      from: eip3009Payload.authorization.from,\n      to: eip3009Payload.authorization.to,\n      value: BigInt(eip3009Payload.authorization.value),\n      validAfter: BigInt(eip3009Payload.authorization.validAfter),\n      validBefore: BigInt(eip3009Payload.authorization.validBefore),\n      nonce: eip3009Payload.authorization.nonce,\n    },\n  };\n\n  // Verify signature\n  try {\n    const recoveredAddress = await signer.verifyTypedData({\n      address: eip3009Payload.authorization.from,\n      ...permitTypedData,\n      signature: eip3009Payload.signature!,\n    });\n\n    if (!recoveredAddress) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_signature\",\n        payer,\n      };\n    }\n  } catch {\n    // Signature verification failed - could be an undeployed smart wallet\n    // Check if smart wallet is deployed\n    const signature = eip3009Payload.signature!;\n    const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n    const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n    if (isSmartWallet) {\n      const payerAddress = eip3009Payload.authorization.from;\n      const bytecode = await signer.getCode({ address: payerAddress });\n\n      if (!bytecode || bytecode === \"0x\") {\n        // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n        const erc6492Data = parseErc6492Signature(signature);\n        const hasDeploymentInfo =\n          erc6492Data.address &&\n          erc6492Data.data &&\n          !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n        if (!hasDeploymentInfo) {\n          // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n            payer: payerAddress,\n          };\n        }\n        // EIP-6492 signature with deployment info - allow through\n      } else {\n        // Wallet is deployed but signature still failed - invalid signature\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer,\n        };\n      }\n    } else {\n      // EOA signature failed\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_signature\",\n        payer,\n      };\n    }\n  }\n\n  // Verify payment recipient matches\n  if (getAddress(eip3009Payload.authorization.to) !== getAddress(requirements.payTo)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n      payer,\n    };\n  }\n\n  // Verify validBefore is in the future (with 6 second buffer for block time)\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(eip3009Payload.authorization.validBefore) < BigInt(now + 6)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n      payer,\n    };\n  }\n\n  // Verify validAfter is not in the future\n  if (BigInt(eip3009Payload.authorization.validAfter) > BigInt(now)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n      payer,\n    };\n  }\n\n  // Check balance\n  try {\n    const balance = (await signer.readContract({\n      address: erc20Address,\n      abi: eip3009ABI,\n      functionName: \"balanceOf\",\n      args: [eip3009Payload.authorization.from],\n    })) as bigint;\n\n    if (BigInt(balance) < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"insufficient_funds\",\n        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check balance, continue with other validations\n  }\n\n  // Verify amount is sufficient\n  if (BigInt(eip3009Payload.authorization.value) < BigInt(requirements.amount)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n      payer,\n    };\n  }\n\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer,\n  };\n}\n\n/**\n * Settles an EIP-3009 payment by executing transferWithAuthorization.\n *\n * @param signer - The facilitator signer for contract writes\n * @param payload - The payment payload to settle\n * @param requirements - The payment requirements\n * @param eip3009Payload - The EIP-3009 specific payload\n * @param config - Facilitator configuration\n * @returns Promise resolving to settlement response\n */\nexport async function settleEIP3009(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  eip3009Payload: ExactEIP3009Payload,\n  config: EIP3009FacilitatorConfig,\n): Promise<SettleResponse> {\n  const payer = eip3009Payload.authorization.from;\n\n  // Re-verify before settling\n  const valid = await verifyEIP3009(signer, payload, requirements, eip3009Payload);\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: payload.accepted.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\",\n      payer,\n    };\n  }\n\n  try {\n    // Parse ERC-6492 signature if applicable\n    const parseResult = parseErc6492Signature(eip3009Payload.signature!);\n    const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n    // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n    if (\n      config.deployERC4337WithEIP6492 &&\n      factoryAddress &&\n      factoryCalldata &&\n      !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n    ) {\n      // Check if smart wallet is already deployed\n      const bytecode = await signer.getCode({ address: payer });\n\n      if (!bytecode || bytecode === \"0x\") {\n        // Wallet not deployed - attempt deployment\n        const deployTx = await signer.sendTransaction({\n          to: factoryAddress as Hex,\n          data: factoryCalldata as Hex,\n        });\n\n        // Wait for deployment transaction\n        await signer.waitForTransactionReceipt({ hash: deployTx });\n      }\n    }\n\n    // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n    const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n    const isECDSA = signatureLength === 130;\n\n    let tx: Hex;\n    if (isECDSA) {\n      // For EOA wallets, parse signature into v, r, s and use that overload\n      const parsedSig = parseSignature(signature);\n\n      tx = await signer.writeContract({\n        address: getAddress(requirements.asset),\n        abi: eip3009ABI,\n        functionName: \"transferWithAuthorization\",\n        args: [\n          getAddress(eip3009Payload.authorization.from),\n          getAddress(eip3009Payload.authorization.to),\n          BigInt(eip3009Payload.authorization.value),\n          BigInt(eip3009Payload.authorization.validAfter),\n          BigInt(eip3009Payload.authorization.validBefore),\n          eip3009Payload.authorization.nonce,\n          (parsedSig.v as number | undefined) || parsedSig.yParity,\n          parsedSig.r,\n          parsedSig.s,\n        ],\n      });\n    } else {\n      // For smart wallets, use the bytes signature overload\n      tx = await signer.writeContract({\n        address: getAddress(requirements.asset),\n        abi: eip3009ABI,\n        functionName: \"transferWithAuthorization\",\n        args: [\n          getAddress(eip3009Payload.authorization.from),\n          getAddress(eip3009Payload.authorization.to),\n          BigInt(eip3009Payload.authorization.value),\n          BigInt(eip3009Payload.authorization.validAfter),\n          BigInt(eip3009Payload.authorization.validBefore),\n          eip3009Payload.authorization.nonce,\n          signature,\n        ],\n      });\n    }\n\n    // Wait for transaction confirmation\n    const receipt = await signer.waitForTransactionReceipt({ hash: tx });\n\n    if (receipt.status !== \"success\") {\n      return {\n        success: false,\n        errorReason: \"invalid_transaction_state\",\n        transaction: tx,\n        network: payload.accepted.network,\n        payer,\n      };\n    }\n\n    return {\n      success: true,\n      transaction: tx,\n      network: payload.accepted.network,\n      payer,\n    };\n  } catch {\n    return {\n      success: false,\n      errorReason: \"transaction_failed\",\n      transaction: \"\",\n      network: payload.accepted.network,\n      payer,\n    };\n  }\n}\n","// EIP-3009 TransferWithAuthorization types for EIP-712 signing\nexport const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n} as const;\n\n/**\n * Permit2 EIP-712 types for signing PermitWitnessTransferFrom.\n * Must match the exact format expected by the Permit2 contract.\n * Note: Types must be in ALPHABETICAL order after the primary type (TokenPermissions < Witness).\n */\nexport const permit2WitnessTypes = {\n  PermitWitnessTransferFrom: [\n    { name: \"permitted\", type: \"TokenPermissions\" },\n    { name: \"spender\", type: \"address\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"deadline\", type: \"uint256\" },\n    { name: \"witness\", type: \"Witness\" },\n  ],\n  TokenPermissions: [\n    { name: \"token\", type: \"address\" },\n    { name: \"amount\", type: \"uint256\" },\n  ],\n  Witness: [\n    { name: \"to\", type: \"address\" },\n    { name: \"validAfter\", type: \"uint256\" },\n  ],\n} as const;\n\n// EIP3009 ABI for transferWithAuthorization function\nexport const eip3009ABI = [\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"v\", type: \"uint8\" },\n      { name: \"r\", type: \"bytes32\" },\n      { name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n\n/**\n * EIP-2612 Permit EIP-712 types for signing token.permit().\n */\nexport const eip2612PermitTypes = {\n  Permit: [\n    { name: \"owner\", type: \"address\" },\n    { name: \"spender\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"nonce\", type: \"uint256\" },\n    { name: \"deadline\", type: \"uint256\" },\n  ],\n} as const;\n\n/**\n * EIP-2612 nonces ABI for querying current nonce.\n */\nexport const eip2612NoncesAbi = [\n  {\n    type: \"function\",\n    name: \"nonces\",\n    inputs: [{ name: \"owner\", type: \"address\" }],\n    outputs: [{ type: \"uint256\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\n/** ERC-20 approve(address,uint256) ABI for encoding/decoding approval calldata. */\nexport const erc20ApproveAbi = [\n  {\n    type: \"function\",\n    name: \"approve\",\n    inputs: [\n      { name: \"spender\", type: \"address\" },\n      { name: \"amount\", type: \"uint256\" },\n    ],\n    outputs: [{ type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n  },\n] as const;\n\n/** ERC-20 allowance(address,address) ABI for checking spender approval. */\nexport const erc20AllowanceAbi = [\n  {\n    type: \"function\",\n    name: \"allowance\",\n    inputs: [\n      { name: \"owner\", type: \"address\" },\n      { name: \"spender\", type: \"address\" },\n    ],\n    outputs: [{ type: \"uint256\" }],\n    stateMutability: \"view\",\n  },\n] as const;\n\n/** Gas limit for a standard ERC-20 approve() transaction. */\nexport const ERC20_APPROVE_GAS_LIMIT = 70_000n;\n\n/** Fallback max fee per gas (1 gwei) when fee estimation fails. */\nexport const DEFAULT_MAX_FEE_PER_GAS = 1_000_000_000n;\n\n/** Fallback max priority fee per gas (0.1 gwei) when fee estimation fails. */\nexport const DEFAULT_MAX_PRIORITY_FEE_PER_GAS = 100_000_000n;\n\n/**\n * Canonical Permit2 contract address.\n * Same address on all EVM chains via CREATE2 deployment.\n *\n * @see https://github.com/Uniswap/permit2\n */\nexport const PERMIT2_ADDRESS = \"0x000000000022D473030F116dDEE9F6B43aC78BA3\" as const;\n\n/**\n * x402ExactPermit2Proxy contract address.\n * Vanity address: 0x4020...0001 for easy recognition.\n * This address is deterministic based on:\n * - Arachnid's deterministic deployer (0x4e59b44847b379578588920cA78FbF26c0B4956C)\n * - Vanity-mined salt for prefix 0x4020 and suffix 0001\n * - Contract bytecode + constructor args (PERMIT2_ADDRESS)\n */\nexport const x402ExactPermit2ProxyAddress = \"0x402085c248EeA27D92E8b30b2C58ed07f9E20001\" as const;\n\n/**\n * x402UptoPermit2Proxy contract address.\n * Vanity address: 0x4020...0002 for easy recognition.\n * This address is deterministic based on:\n * - Arachnid's deterministic deployer (0x4e59b44847b379578588920cA78FbF26c0B4956C)\n * - Vanity-mined salt for prefix 0x4020 and suffix 0002\n * - Contract bytecode + constructor args (PERMIT2_ADDRESS)\n */\nexport const x402UptoPermit2ProxyAddress = \"0x402039b3d6E6BEC5A02c2C9fd937ac17A6940002\" as const;\n\n/**\n * Shared ABI components for the Permit2 witness tuple.\n * Used in both x402ExactPermit2ProxyABI and x402UptoPermit2ProxyABI to keep them in sync.\n * The upto contract's witness struct is identical to exact (both remove 'extra' post-audit).\n */\nconst permit2WitnessABIComponents = [\n  { name: \"to\", type: \"address\", internalType: \"address\" },\n  { name: \"validAfter\", type: \"uint256\", internalType: \"uint256\" },\n] as const;\n\n/**\n * x402UptoPermit2Proxy ABI - settle function for upto payment scheme (variable amounts).\n * Updated post-audit: 'extra' removed from witness struct, 'initialize()' removed (now\n * a constructor arg), and error names aligned with x402ExactPermit2Proxy.\n */\nexport const x402UptoPermit2ProxyABI = [\n  {\n    type: \"function\",\n    name: \"PERMIT2\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"address\", internalType: \"contract ISignatureTransfer\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPEHASH\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"bytes32\", internalType: \"bytes32\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPE_STRING\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"string\", internalType: \"string\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"settle\",\n    inputs: [\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402UptoPermit2Proxy.Witness\",\n        components: permit2WitnessABIComponents,\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"settleWithPermit\",\n    inputs: [\n      {\n        name: \"permit2612\",\n        type: \"tuple\",\n        internalType: \"struct x402UptoPermit2Proxy.EIP2612Permit\",\n        components: [\n          { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"r\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"s\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"v\", type: \"uint8\", internalType: \"uint8\" },\n        ],\n      },\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402UptoPermit2Proxy.Witness\",\n        components: permit2WitnessABIComponents,\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  { type: \"event\", name: \"Settled\", inputs: [], anonymous: false },\n  { type: \"event\", name: \"SettledWithPermit\", inputs: [], anonymous: false },\n  { type: \"error\", name: \"InvalidAmount\", inputs: [] },\n  { type: \"error\", name: \"InvalidDestination\", inputs: [] },\n  { type: \"error\", name: \"InvalidOwner\", inputs: [] },\n  { type: \"error\", name: \"InvalidPermit2Address\", inputs: [] },\n  { type: \"error\", name: \"PaymentTooEarly\", inputs: [] },\n  { type: \"error\", name: \"Permit2612AmountMismatch\", inputs: [] },\n  { type: \"error\", name: \"ReentrancyGuardReentrantCall\", inputs: [] },\n] as const;\n\n/**\n * x402ExactPermit2Proxy ABI - settle function for exact payment scheme.\n */\nexport const x402ExactPermit2ProxyABI = [\n  {\n    type: \"function\",\n    name: \"PERMIT2\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"address\", internalType: \"contract ISignatureTransfer\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPEHASH\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"bytes32\", internalType: \"bytes32\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"WITNESS_TYPE_STRING\",\n    inputs: [],\n    outputs: [{ name: \"\", type: \"string\", internalType: \"string\" }],\n    stateMutability: \"view\",\n  },\n  {\n    type: \"function\",\n    name: \"settle\",\n    inputs: [\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402ExactPermit2Proxy.Witness\",\n        components: permit2WitnessABIComponents,\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  {\n    type: \"function\",\n    name: \"settleWithPermit\",\n    inputs: [\n      {\n        name: \"permit2612\",\n        type: \"tuple\",\n        internalType: \"struct x402ExactPermit2Proxy.EIP2612Permit\",\n        components: [\n          { name: \"value\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"r\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"s\", type: \"bytes32\", internalType: \"bytes32\" },\n          { name: \"v\", type: \"uint8\", internalType: \"uint8\" },\n        ],\n      },\n      {\n        name: \"permit\",\n        type: \"tuple\",\n        internalType: \"struct ISignatureTransfer.PermitTransferFrom\",\n        components: [\n          {\n            name: \"permitted\",\n            type: \"tuple\",\n            internalType: \"struct ISignatureTransfer.TokenPermissions\",\n            components: [\n              { name: \"token\", type: \"address\", internalType: \"address\" },\n              { name: \"amount\", type: \"uint256\", internalType: \"uint256\" },\n            ],\n          },\n          { name: \"nonce\", type: \"uint256\", internalType: \"uint256\" },\n          { name: \"deadline\", type: \"uint256\", internalType: \"uint256\" },\n        ],\n      },\n      { name: \"owner\", type: \"address\", internalType: \"address\" },\n      {\n        name: \"witness\",\n        type: \"tuple\",\n        internalType: \"struct x402ExactPermit2Proxy.Witness\",\n        components: permit2WitnessABIComponents,\n      },\n      { name: \"signature\", type: \"bytes\", internalType: \"bytes\" },\n    ],\n    outputs: [],\n    stateMutability: \"nonpayable\",\n  },\n  { type: \"event\", name: \"Settled\", inputs: [], anonymous: false },\n  { type: \"event\", name: \"SettledWithPermit\", inputs: [], anonymous: false },\n  { type: \"error\", name: \"InvalidAmount\", inputs: [] },\n  { type: \"error\", name: \"InvalidDestination\", inputs: [] },\n  { type: \"error\", name: \"InvalidOwner\", inputs: [] },\n  { type: \"error\", name: \"InvalidPermit2Address\", inputs: [] },\n  { type: \"error\", name: \"PaymentTooEarly\", inputs: [] },\n  { type: \"error\", name: \"Permit2612AmountMismatch\", inputs: [] },\n  { type: \"error\", name: \"ReentrancyGuardReentrantCall\", inputs: [] },\n] as const;\n","import { toHex } from \"viem\";\n\n/**\n * Extract chain ID from a CAIP-2 network identifier (eip155:CHAIN_ID).\n *\n * @param network - The network identifier in CAIP-2 format (e.g., \"eip155:8453\")\n * @returns The numeric chain ID\n * @throws Error if the network format is invalid\n */\nexport function getEvmChainId(network: string): number {\n  if (network.startsWith(\"eip155:\")) {\n    const idStr = network.split(\":\")[1];\n    const chainId = parseInt(idStr, 10);\n    if (isNaN(chainId)) {\n      throw new Error(`Invalid CAIP-2 chain ID: ${network}`);\n    }\n    return chainId;\n  }\n\n  throw new Error(`Unsupported network format: ${network} (expected eip155:CHAIN_ID)`);\n}\n\n/**\n * Get the crypto object from the global scope.\n *\n * @returns The crypto object\n * @throws Error if crypto API is not available\n */\nfunction getCrypto(): Crypto {\n  const cryptoObj = globalThis.crypto as Crypto | undefined;\n  if (!cryptoObj) {\n    throw new Error(\"Crypto API not available\");\n  }\n  return cryptoObj;\n}\n\n/**\n * Create a random 32-byte nonce for EIP-3009 authorization.\n *\n * @returns A hex-encoded 32-byte nonce\n */\nexport function createNonce(): `0x${string}` {\n  return toHex(getCrypto().getRandomValues(new Uint8Array(32)));\n}\n\n/**\n * Creates a random 256-bit nonce for Permit2.\n * Permit2 uses uint256 nonces (not bytes32 like EIP-3009).\n *\n * @returns A string representation of the random nonce\n */\nexport function createPermit2Nonce(): string {\n  const randomBytes = getCrypto().getRandomValues(new Uint8Array(32));\n  return BigInt(toHex(randomBytes)).toString();\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  FacilitatorContext,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport {\n  extractEip2612GasSponsoringInfo,\n  validateEip2612GasSponsoringInfo,\n  extractErc20ApprovalGasSponsoringInfo,\n  ERC20_APPROVAL_GAS_SPONSORING,\n  type Erc20ApprovalGasSponsoringFacilitatorExtension,\n} from \"@x402/extensions\";\nimport type { Eip2612GasSponsoringInfo } from \"@x402/extensions\";\nimport { getAddress } from \"viem\";\nimport {\n  eip3009ABI,\n  PERMIT2_ADDRESS,\n  permit2WitnessTypes,\n  x402ExactPermit2ProxyABI,\n  x402ExactPermit2ProxyAddress,\n  erc20AllowanceAbi,\n} from \"../../constants\";\nimport {\n  ErrPermit2612AmountMismatch,\n  ErrPermit2InvalidAmount,\n  ErrPermit2InvalidDestination,\n  ErrPermit2InvalidNonce,\n  ErrPermit2InvalidOwner,\n  ErrPermit2InvalidSignature,\n  ErrPermit2PaymentTooEarly,\n} from \"./errors\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactPermit2Payload } from \"../../types\";\nimport { getEvmChainId } from \"../../utils\";\nimport { validateErc20ApprovalForPayment } from \"./erc20approval\";\n\n/**\n * Verifies a Permit2 payment payload.\n *\n * Handles all Permit2 verification paths:\n * - Standard: checks on-chain Permit2 allowance\n * - EIP-2612: validates the EIP-2612 permit extension when allowance is insufficient\n * - ERC-20 approval: validates the pre-signed approve tx extension when allowance is insufficient\n *\n * @param signer - The facilitator signer for contract reads\n * @param payload - The payment payload to verify\n * @param requirements - The payment requirements\n * @param permit2Payload - The Permit2 specific payload\n * @param context - Optional facilitator context for extension-provided capabilities\n * @returns Promise resolving to verification response\n */\nexport async function verifyPermit2(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  permit2Payload: ExactPermit2Payload,\n  context?: FacilitatorContext,\n): Promise<VerifyResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n    return {\n      isValid: false,\n      invalidReason: \"unsupported_scheme\",\n      payer,\n    };\n  }\n\n  if (payload.accepted.network !== requirements.network) {\n    return {\n      isValid: false,\n      invalidReason: \"network_mismatch\",\n      payer,\n    };\n  }\n\n  const chainId = getEvmChainId(requirements.network);\n  const tokenAddress = getAddress(requirements.asset);\n\n  if (\n    getAddress(permit2Payload.permit2Authorization.spender) !==\n    getAddress(x402ExactPermit2ProxyAddress)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_spender\",\n      payer,\n    };\n  }\n\n  if (\n    getAddress(permit2Payload.permit2Authorization.witness.to) !== getAddress(requirements.payTo)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_recipient_mismatch\",\n      payer,\n    };\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(permit2Payload.permit2Authorization.deadline) < BigInt(now + 6)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_deadline_expired\",\n      payer,\n    };\n  }\n\n  if (BigInt(permit2Payload.permit2Authorization.witness.validAfter) > BigInt(now)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_not_yet_valid\",\n      payer,\n    };\n  }\n\n  if (BigInt(permit2Payload.permit2Authorization.permitted.amount) < BigInt(requirements.amount)) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_insufficient_amount\",\n      payer,\n    };\n  }\n\n  if (getAddress(permit2Payload.permit2Authorization.permitted.token) !== tokenAddress) {\n    return {\n      isValid: false,\n      invalidReason: \"permit2_token_mismatch\",\n      payer,\n    };\n  }\n\n  const permit2TypedData = {\n    types: permit2WitnessTypes,\n    primaryType: \"PermitWitnessTransferFrom\" as const,\n    domain: {\n      name: \"Permit2\",\n      chainId,\n      verifyingContract: PERMIT2_ADDRESS,\n    },\n    message: {\n      permitted: {\n        token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n        amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n      },\n      spender: getAddress(permit2Payload.permit2Authorization.spender),\n      nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n      deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n      witness: {\n        to: getAddress(permit2Payload.permit2Authorization.witness.to),\n        validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n      },\n    },\n  };\n\n  try {\n    const isValid = await signer.verifyTypedData({\n      address: payer,\n      ...permit2TypedData,\n      signature: permit2Payload.signature,\n    });\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_permit2_signature\",\n        payer,\n      };\n    }\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_permit2_signature\",\n      payer,\n    };\n  }\n\n  // Check Permit2 allowance — if insufficient, try gas sponsoring extensions\n  const allowanceResult = await _verifyPermit2Allowance(\n    signer,\n    payload,\n    requirements,\n    payer,\n    tokenAddress,\n    context,\n  );\n  if (allowanceResult) {\n    return allowanceResult;\n  }\n\n  try {\n    const balance = (await signer.readContract({\n      address: tokenAddress,\n      abi: eip3009ABI,\n      functionName: \"balanceOf\",\n      args: [payer],\n    })) as bigint;\n\n    if (balance < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"insufficient_funds\",\n        invalidMessage: `Insufficient funds to complete the payment. Required: ${requirements.amount} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n        payer,\n      };\n    }\n  } catch {\n    // If we can't check balance, continue\n  }\n\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer,\n  };\n}\n\n/**\n * Checks Permit2 allowance and validates gas sponsoring extensions if allowance is insufficient.\n *\n * @param signer - The facilitator signer for on-chain reads\n * @param payload - The payment payload\n * @param requirements - The payment requirements\n * @param payer - The payer address\n * @param tokenAddress - The token contract address\n * @param context - Optional facilitator context for extension lookup\n * @returns A VerifyResponse if verification should stop (failure), or null to continue\n */\nasync function _verifyPermit2Allowance(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  payer: `0x${string}`,\n  tokenAddress: `0x${string}`,\n  context?: FacilitatorContext,\n): Promise<VerifyResponse | null> {\n  try {\n    const allowance = (await signer.readContract({\n      address: tokenAddress,\n      abi: erc20AllowanceAbi,\n      functionName: \"allowance\",\n      args: [payer, PERMIT2_ADDRESS],\n    })) as bigint;\n\n    if (allowance >= BigInt(requirements.amount)) {\n      return null; // Sufficient allowance, continue verification\n    }\n\n    // Allowance insufficient — try EIP-2612 gas sponsoring first\n    const eip2612Info = extractEip2612GasSponsoringInfo(payload);\n    if (eip2612Info) {\n      const result = validateEip2612PermitForPayment(eip2612Info, payer, tokenAddress);\n      if (!result.isValid) {\n        return { isValid: false, invalidReason: result.invalidReason!, payer };\n      }\n      return null; // EIP-2612 is valid, allowance will be set atomically during settlement\n    }\n\n    // Try ERC-20 approval gas sponsoring as fallback\n    const erc20GasSponsorshipExtension =\n      context?.getExtension<Erc20ApprovalGasSponsoringFacilitatorExtension>(\n        ERC20_APPROVAL_GAS_SPONSORING.key,\n      );\n    if (erc20GasSponsorshipExtension) {\n      const erc20Info = extractErc20ApprovalGasSponsoringInfo(payload);\n      if (erc20Info) {\n        const result = await validateErc20ApprovalForPayment(erc20Info, payer, tokenAddress);\n        if (!result.isValid) {\n          return { isValid: false, invalidReason: result.invalidReason!, payer };\n        }\n        return null; // ERC-20 approval is valid, will be broadcast before settlement\n      }\n    }\n\n    return { isValid: false, invalidReason: \"permit2_allowance_required\", payer };\n  } catch {\n    // If allowance check fails, validate extensions if present; otherwise proceed optimistically\n    const eip2612Info = extractEip2612GasSponsoringInfo(payload);\n    if (eip2612Info) {\n      const result = validateEip2612PermitForPayment(eip2612Info, payer, tokenAddress);\n      if (!result.isValid) {\n        return { isValid: false, invalidReason: result.invalidReason!, payer };\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Settles a Permit2 payment. Single entry point for all Permit2 settlement paths:\n *\n * 1. EIP-2612 extension present -> settleWithPermit (atomic single tx via contract)\n * 2. ERC-20 approval extension present + extension signer -> broadcast approval + settle (via extension signer)\n * 3. Standard -> settle directly (allowance already on-chain)\n *\n * @param signer - The base facilitator signer for contract writes\n * @param payload - The payment payload to settle\n * @param requirements - The payment requirements\n * @param permit2Payload - The Permit2 specific payload\n * @param context - Optional facilitator context for extension-provided capabilities\n * @returns Promise resolving to settlement response\n */\nexport async function settlePermit2(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  requirements: PaymentRequirements,\n  permit2Payload: ExactPermit2Payload,\n  context?: FacilitatorContext,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  const valid = await verifyPermit2(signer, payload, requirements, permit2Payload, context);\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: payload.accepted.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\",\n      payer,\n    };\n  }\n\n  // Branch: EIP-2612 gas sponsoring (atomic settleWithPermit via contract)\n  const eip2612Info = extractEip2612GasSponsoringInfo(payload);\n  if (eip2612Info) {\n    return _settlePermit2WithEIP2612(signer, payload, permit2Payload, eip2612Info);\n  }\n\n  // Branch: ERC-20 approval gas sponsoring (broadcast approval + settle via extension signer)\n  const erc20Info = extractErc20ApprovalGasSponsoringInfo(payload);\n  if (erc20Info) {\n    const erc20GasSponsorshipExtension =\n      context?.getExtension<Erc20ApprovalGasSponsoringFacilitatorExtension>(\n        ERC20_APPROVAL_GAS_SPONSORING.key,\n      );\n    if (erc20GasSponsorshipExtension?.signer) {\n      return _settlePermit2WithERC20Approval(\n        erc20GasSponsorshipExtension.signer,\n        payload,\n        permit2Payload,\n        erc20Info,\n      );\n    }\n  }\n\n  // Branch: standard settle (allowance already on-chain)\n  return _settlePermit2Direct(signer, payload, permit2Payload);\n}\n\n/**\n * Settles via settleWithPermit — includes the EIP-2612 permit atomically in one tx.\n *\n * @param signer - The base facilitator signer\n * @param payload - The payment payload\n * @param permit2Payload - The Permit2 specific payload\n * @param eip2612Info - The EIP-2612 gas sponsoring info from the payload extension\n * @returns Promise resolving to settlement response\n */\nasync function _settlePermit2WithEIP2612(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  permit2Payload: ExactPermit2Payload,\n  eip2612Info: Eip2612GasSponsoringInfo,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n  try {\n    const { v, r, s } = splitEip2612Signature(eip2612Info.signature);\n\n    const tx = await signer.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settleWithPermit\",\n      args: [\n        {\n          value: BigInt(eip2612Info.amount),\n          deadline: BigInt(eip2612Info.deadline),\n          r,\n          s,\n          v,\n        },\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    return _waitAndReturn(signer, tx, payload, payer);\n  } catch (error) {\n    return _mapSettleError(error, payload, payer);\n  }\n}\n\n/**\n * Broadcasts the pre-signed ERC-20 approve tx then settles via the extension signer.\n * Both operations use the extension signer, enabling atomic bundling by production implementations.\n *\n * @param extensionSigner - The extension signer with sendRawTransaction + writeContract\n * @param payload - The payment payload\n * @param permit2Payload - The Permit2 specific payload\n * @param erc20Info - Object containing the signed approval transaction\n * @param erc20Info.signedTransaction - The RLP-encoded signed EIP-1559 approval tx\n * @returns Promise resolving to settlement response\n */\nasync function _settlePermit2WithERC20Approval(\n  extensionSigner: Erc20ApprovalGasSponsoringFacilitatorExtension[\"signer\"] & {},\n  payload: PaymentPayload,\n  permit2Payload: ExactPermit2Payload,\n  erc20Info: { signedTransaction: string },\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n\n  try {\n    const approvalTxHash = await extensionSigner.sendRawTransaction({\n      serializedTransaction: erc20Info.signedTransaction as `0x${string}`,\n    });\n\n    const approvalReceipt = await extensionSigner.waitForTransactionReceipt({\n      hash: approvalTxHash,\n    });\n\n    if (approvalReceipt.status !== \"success\") {\n      return {\n        success: false,\n        errorReason: \"erc20_approval_tx_failed\",\n        transaction: approvalTxHash,\n        network: payload.accepted.network,\n        payer,\n      };\n    }\n\n    const tx = await extensionSigner.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settle\",\n      args: [\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    return _waitAndReturn(extensionSigner, tx, payload, payer);\n  } catch (error) {\n    return _mapSettleError(error, payload, payer);\n  }\n}\n\n/**\n * Standard Permit2 settle — allowance is already on-chain.\n *\n * @param signer - The base facilitator signer\n * @param payload - The payment payload\n * @param permit2Payload - The Permit2 specific payload\n * @returns Promise resolving to settlement response\n */\nasync function _settlePermit2Direct(\n  signer: FacilitatorEvmSigner,\n  payload: PaymentPayload,\n  permit2Payload: ExactPermit2Payload,\n): Promise<SettleResponse> {\n  const payer = permit2Payload.permit2Authorization.from;\n  try {\n    const tx = await signer.writeContract({\n      address: x402ExactPermit2ProxyAddress,\n      abi: x402ExactPermit2ProxyABI,\n      functionName: \"settle\",\n      args: [\n        {\n          permitted: {\n            token: getAddress(permit2Payload.permit2Authorization.permitted.token),\n            amount: BigInt(permit2Payload.permit2Authorization.permitted.amount),\n          },\n          nonce: BigInt(permit2Payload.permit2Authorization.nonce),\n          deadline: BigInt(permit2Payload.permit2Authorization.deadline),\n        },\n        getAddress(payer),\n        {\n          to: getAddress(permit2Payload.permit2Authorization.witness.to),\n          validAfter: BigInt(permit2Payload.permit2Authorization.witness.validAfter),\n        },\n        permit2Payload.signature,\n      ],\n    });\n\n    return _waitAndReturn(signer, tx, payload, payer);\n  } catch (error) {\n    return _mapSettleError(error, payload, payer);\n  }\n}\n\n/**\n * Waits for tx receipt and returns the appropriate SettleResponse.\n *\n * @param signer - Signer with waitForTransactionReceipt capability\n * @param tx - The transaction hash to wait for\n * @param payload - The payment payload (for network info)\n * @param payer - The payer address\n * @returns Promise resolving to settlement response\n */\nasync function _waitAndReturn(\n  signer: Pick<FacilitatorEvmSigner, \"waitForTransactionReceipt\">,\n  tx: `0x${string}`,\n  payload: PaymentPayload,\n  payer: `0x${string}`,\n): Promise<SettleResponse> {\n  const receipt = await signer.waitForTransactionReceipt({ hash: tx });\n\n  if (receipt.status !== \"success\") {\n    return {\n      success: false,\n      errorReason: \"invalid_transaction_state\",\n      transaction: tx,\n      network: payload.accepted.network,\n      payer,\n    };\n  }\n\n  return {\n    success: true,\n    transaction: tx,\n    network: payload.accepted.network,\n    payer,\n  };\n}\n\n/**\n * Maps contract revert errors to structured SettleResponse error reasons.\n *\n * @param error - The caught error\n * @param payload - The payment payload (for network info)\n * @param payer - The payer address\n * @returns A failed SettleResponse with mapped error reason\n */\nfunction _mapSettleError(\n  error: unknown,\n  payload: PaymentPayload,\n  payer: `0x${string}`,\n): SettleResponse {\n  let errorReason = \"transaction_failed\";\n  if (error instanceof Error) {\n    const message = error.message;\n    if (message.includes(\"Permit2612AmountMismatch\")) {\n      errorReason = ErrPermit2612AmountMismatch;\n    } else if (message.includes(\"InvalidAmount\")) {\n      errorReason = ErrPermit2InvalidAmount;\n    } else if (message.includes(\"InvalidDestination\")) {\n      errorReason = ErrPermit2InvalidDestination;\n    } else if (message.includes(\"InvalidOwner\")) {\n      errorReason = ErrPermit2InvalidOwner;\n    } else if (message.includes(\"PaymentTooEarly\")) {\n      errorReason = ErrPermit2PaymentTooEarly;\n    } else if (message.includes(\"InvalidSignature\") || message.includes(\"SignatureExpired\")) {\n      errorReason = ErrPermit2InvalidSignature;\n    } else if (message.includes(\"InvalidNonce\")) {\n      errorReason = ErrPermit2InvalidNonce;\n    } else {\n      errorReason = `transaction_failed: ${message.slice(0, 500)}`;\n    }\n  }\n  return {\n    success: false,\n    errorReason,\n    transaction: \"\",\n    network: payload.accepted.network,\n    payer,\n  };\n}\n\n/**\n * Validates EIP-2612 permit extension data for a Permit2 payment.\n *\n * @param info - The EIP-2612 gas sponsoring info\n * @param payer - The expected payer address\n * @param tokenAddress - The expected token address\n * @returns Validation result with optional invalidReason\n */\nfunction validateEip2612PermitForPayment(\n  info: Eip2612GasSponsoringInfo,\n  payer: `0x${string}`,\n  tokenAddress: `0x${string}`,\n): { isValid: boolean; invalidReason?: string } {\n  if (!validateEip2612GasSponsoringInfo(info)) {\n    return { isValid: false, invalidReason: \"invalid_eip2612_extension_format\" };\n  }\n\n  if (getAddress(info.from as `0x${string}`) !== getAddress(payer)) {\n    return { isValid: false, invalidReason: \"eip2612_from_mismatch\" };\n  }\n\n  if (getAddress(info.asset as `0x${string}`) !== tokenAddress) {\n    return { isValid: false, invalidReason: \"eip2612_asset_mismatch\" };\n  }\n\n  if (getAddress(info.spender as `0x${string}`) !== getAddress(PERMIT2_ADDRESS)) {\n    return { isValid: false, invalidReason: \"eip2612_spender_not_permit2\" };\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  if (BigInt(info.deadline) < BigInt(now + 6)) {\n    return { isValid: false, invalidReason: \"eip2612_deadline_expired\" };\n  }\n\n  return { isValid: true };\n}\n\n/**\n * Splits a 65-byte EIP-2612 signature into v, r, s components.\n *\n * @param signature - The hex-encoded 65-byte signature\n * @returns Object with v (uint8), r (bytes32), s (bytes32)\n */\nfunction splitEip2612Signature(signature: string): {\n  v: number;\n  r: `0x${string}`;\n  s: `0x${string}`;\n} {\n  const sig = signature.startsWith(\"0x\") ? signature.slice(2) : signature;\n\n  if (sig.length !== 130) {\n    throw new Error(\n      `invalid EIP-2612 signature length: expected 65 bytes (130 hex chars), got ${sig.length / 2} bytes`,\n    );\n  }\n\n  const r = `0x${sig.slice(0, 64)}` as `0x${string}`;\n  const s = `0x${sig.slice(64, 128)}` as `0x${string}`;\n  const v = parseInt(sig.slice(128, 130), 16);\n\n  return { v, r, s };\n}\n","/**\n * Named error reason constants for the exact EVM facilitator.\n *\n * These strings must be character-for-character identical to the Go constants in\n * go/mechanisms/evm/exact/facilitator/errors.go to maintain cross-SDK parity.\n */\n\n// EIP-3009 verify errors\nexport const ErrInvalidScheme = \"invalid_exact_evm_scheme\";\nexport const ErrNetworkMismatch = \"invalid_exact_evm_network_mismatch\";\n\n// Permit2 verify errors\nexport const ErrPermit2InvalidSpender = \"invalid_permit2_spender\";\nexport const ErrPermit2RecipientMismatch = \"invalid_permit2_recipient_mismatch\";\nexport const ErrPermit2DeadlineExpired = \"permit2_deadline_expired\";\nexport const ErrPermit2NotYetValid = \"permit2_not_yet_valid\";\nexport const ErrPermit2InsufficientAmount = \"permit2_insufficient_amount\";\nexport const ErrPermit2TokenMismatch = \"permit2_token_mismatch\";\nexport const ErrPermit2InvalidSignature = \"invalid_permit2_signature\";\nexport const ErrPermit2AllowanceRequired = \"permit2_allowance_required\";\n\n// Permit2 settle errors (from contract reverts)\nexport const ErrPermit2InvalidAmount = \"permit2_invalid_amount\";\nexport const ErrPermit2InvalidDestination = \"permit2_invalid_destination\";\nexport const ErrPermit2InvalidOwner = \"permit2_invalid_owner\";\nexport const ErrPermit2PaymentTooEarly = \"permit2_payment_too_early\";\nexport const ErrPermit2InvalidNonce = \"permit2_invalid_nonce\";\nexport const ErrPermit2612AmountMismatch = \"permit2_2612_amount_mismatch\";\n\n// ERC-20 approval gas sponsoring verify errors\nexport const ErrErc20ApprovalInvalidFormat = \"invalid_erc20_approval_extension_format\";\nexport const ErrErc20ApprovalFromMismatch = \"erc20_approval_from_mismatch\";\nexport const ErrErc20ApprovalAssetMismatch = \"erc20_approval_asset_mismatch\";\nexport const ErrErc20ApprovalSpenderNotPermit2 = \"erc20_approval_spender_not_permit2\";\nexport const ErrErc20ApprovalTxWrongTarget = \"erc20_approval_tx_wrong_target\";\nexport const ErrErc20ApprovalTxWrongSelector = \"erc20_approval_tx_wrong_selector\";\nexport const ErrErc20ApprovalTxWrongSpender = \"erc20_approval_tx_wrong_spender\";\nexport const ErrErc20ApprovalTxInvalidCalldata = \"erc20_approval_tx_invalid_calldata\";\nexport const ErrErc20ApprovalTxSignerMismatch = \"erc20_approval_tx_signer_mismatch\";\nexport const ErrErc20ApprovalTxInvalidSignature = \"erc20_approval_tx_invalid_signature\";\nexport const ErrErc20ApprovalTxParseFailed = \"erc20_approval_tx_parse_failed\";\n","import {\n  getAddress,\n  parseTransaction,\n  decodeFunctionData,\n  recoverTransactionAddress,\n  type TransactionSerialized,\n} from \"viem\";\nimport type { VerifyResponse } from \"@x402/core/types\";\nimport {\n  validateErc20ApprovalGasSponsoringInfo,\n  type Erc20ApprovalGasSponsoringInfo,\n} from \"@x402/extensions\";\nimport { PERMIT2_ADDRESS, erc20ApproveAbi } from \"../../constants\";\nimport {\n  ErrErc20ApprovalInvalidFormat,\n  ErrErc20ApprovalFromMismatch,\n  ErrErc20ApprovalAssetMismatch,\n  ErrErc20ApprovalSpenderNotPermit2,\n  ErrErc20ApprovalTxWrongTarget,\n  ErrErc20ApprovalTxWrongSelector,\n  ErrErc20ApprovalTxWrongSpender,\n  ErrErc20ApprovalTxInvalidCalldata,\n  ErrErc20ApprovalTxSignerMismatch,\n  ErrErc20ApprovalTxInvalidSignature,\n  ErrErc20ApprovalTxParseFailed,\n} from \"./errors\";\n\n/** The approve(address,uint256) function selector */\nconst APPROVE_SELECTOR = \"0x095ea7b3\";\n\n/**\n * Validates ERC-20 approval extension data for a Permit2 payment.\n *\n * Performs comprehensive validation:\n * - Format validation via validateErc20ApprovalGasSponsoringInfo (JSON Schema)\n * - `from` matches payer\n * - `asset` matches token\n * - `spender` is PERMIT2_ADDRESS\n * - Transaction `to` matches token address\n * - Transaction calldata is a valid approve(PERMIT2_ADDRESS, ...) call\n * - Recovered transaction signer matches `from`\n *\n * @param info - The ERC-20 approval gas sponsoring info\n * @param payer - The expected payer address\n * @param tokenAddress - The expected token address\n * @returns Validation result with invalidReason and invalidMessage on failure\n */\nexport async function validateErc20ApprovalForPayment(\n  info: Erc20ApprovalGasSponsoringInfo,\n  payer: `0x${string}`,\n  tokenAddress: `0x${string}`,\n): Promise<Pick<VerifyResponse, \"isValid\" | \"invalidReason\" | \"invalidMessage\">> {\n  if (!validateErc20ApprovalGasSponsoringInfo(info)) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalInvalidFormat,\n      invalidMessage: \"ERC-20 approval extension info failed schema validation\",\n    };\n  }\n\n  if (getAddress(info.from) !== getAddress(payer)) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalFromMismatch,\n      invalidMessage: `Expected from=${payer}, got ${info.from}`,\n    };\n  }\n\n  if (getAddress(info.asset) !== tokenAddress) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalAssetMismatch,\n      invalidMessage: `Expected asset=${tokenAddress}, got ${info.asset}`,\n    };\n  }\n\n  if (getAddress(info.spender) !== getAddress(PERMIT2_ADDRESS)) {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalSpenderNotPermit2,\n      invalidMessage: `Expected spender=${PERMIT2_ADDRESS}, got ${info.spender}`,\n    };\n  }\n\n  try {\n    const serializedTx = info.signedTransaction as TransactionSerialized;\n    const tx = parseTransaction(serializedTx);\n\n    if (!tx.to || getAddress(tx.to) !== tokenAddress) {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxWrongTarget,\n        invalidMessage: `Transaction targets ${tx.to ?? \"null\"}, expected ${tokenAddress}`,\n      };\n    }\n\n    const data = tx.data ?? \"0x\";\n    if (!data.startsWith(APPROVE_SELECTOR)) {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxWrongSelector,\n        invalidMessage: `Transaction calldata does not start with approve() selector ${APPROVE_SELECTOR}`,\n      };\n    }\n\n    try {\n      const decoded = decodeFunctionData({\n        abi: erc20ApproveAbi,\n        data: data as `0x${string}`,\n      });\n      const calldataSpender = getAddress(decoded.args[0] as `0x${string}`);\n      if (calldataSpender !== getAddress(PERMIT2_ADDRESS)) {\n        return {\n          isValid: false,\n          invalidReason: ErrErc20ApprovalTxWrongSpender,\n          invalidMessage: `approve() spender is ${calldataSpender}, expected Permit2 ${PERMIT2_ADDRESS}`,\n        };\n      }\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxInvalidCalldata,\n        invalidMessage: \"Failed to decode approve() calldata from the signed transaction\",\n      };\n    }\n\n    try {\n      const recoveredAddress = await recoverTransactionAddress({\n        serializedTransaction: serializedTx,\n      });\n      if (getAddress(recoveredAddress) !== getAddress(payer)) {\n        return {\n          isValid: false,\n          invalidReason: ErrErc20ApprovalTxSignerMismatch,\n          invalidMessage: `Transaction signed by ${recoveredAddress}, expected payer ${payer}`,\n        };\n      }\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: ErrErc20ApprovalTxInvalidSignature,\n        invalidMessage: \"Failed to recover signer from the signed transaction\",\n      };\n    }\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: ErrErc20ApprovalTxParseFailed,\n      invalidMessage: \"Failed to parse the signed transaction\",\n    };\n  }\n\n  return { isValid: true };\n}\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  FacilitatorContext,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmPayloadV2, ExactEIP3009Payload, isPermit2Payload } from \"../../types\";\nimport { verifyEIP3009, settleEIP3009 } from \"./eip3009\";\nimport { verifyPermit2, settlePermit2 } from \"./permit2\";\n\nexport interface ExactEvmSchemeConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme.\n * Thin router that delegates to EIP-3009 or Permit2 based on payload type.\n * All extension handling (EIP-2612, ERC-20 approval gas sponsoring) is owned\n * by the Permit2 functions via FacilitatorContext.\n */\nexport class ExactEvmScheme implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeConfig>;\n\n  /**\n   * Creates a new ExactEvmScheme facilitator instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeConfig,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Returns undefined — EVM has no mechanism-specific extra data.\n   *\n   * @param _ - The network identifier (unused)\n   * @returns undefined\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Returns facilitator wallet addresses for the supported response.\n   *\n   * @param _ - The network identifier (unused, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload. Routes to Permit2 or EIP-3009 based on payload type.\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @param context - Optional facilitator context for extension capabilities\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n    context?: FacilitatorContext,\n  ): Promise<VerifyResponse> {\n    const rawPayload = payload.payload as ExactEvmPayloadV2;\n\n    if (isPermit2Payload(rawPayload)) {\n      return verifyPermit2(this.signer, payload, requirements, rawPayload, context);\n    }\n\n    const eip3009Payload: ExactEIP3009Payload = rawPayload;\n    return verifyEIP3009(this.signer, payload, requirements, eip3009Payload);\n  }\n\n  /**\n   * Settles a payment. Routes to Permit2 or EIP-3009 based on payload type.\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @param context - Optional facilitator context for extension capabilities\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n    context?: FacilitatorContext,\n  ): Promise<SettleResponse> {\n    const rawPayload = payload.payload as ExactEvmPayloadV2;\n\n    if (isPermit2Payload(rawPayload)) {\n      return settlePermit2(this.signer, payload, requirements, rawPayload, context);\n    }\n\n    const eip3009Payload: ExactEIP3009Payload = rawPayload;\n    return settleEIP3009(this.signer, payload, requirements, eip3009Payload, this.config);\n  }\n}\n","import {\n  PaymentPayload,\n  PaymentPayloadV1,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../../constants\";\nimport { FacilitatorEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { EvmNetworkV1, getEvmChainIdV1 } from \"../../../v1\";\n\nexport interface ExactEvmSchemeV1Config {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeV1Config>;\n\n  /**\n   * Creates a new ExactEvmFacilitatorV1 instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration for the facilitator\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeV1Config,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   * For EVM, no extra data is needed.\n   *\n   * @param _ - The network identifier (unused for EVM)\n   * @returns undefined (EVM has no extra data)\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * Returns all addresses this facilitator can use for signing/settling transactions.\n   *\n   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload (V1).\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const requirementsV1 = requirements as unknown as PaymentRequirementsV1;\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV1;\n\n    // Verify scheme matches\n    if (payloadV1.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n      return {\n        isValid: false,\n        invalidReason: \"unsupported_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Get chain configuration\n    let chainId: number;\n    try {\n      chainId = getEvmChainIdV1(payloadV1.network as EvmNetworkV1);\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: `invalid_network`,\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      return {\n        isValid: false,\n        invalidReason: \"missing_eip712_domain\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    const { name, version } = requirements.extra;\n    const erc20Address = getAddress(requirements.asset);\n\n    // Verify network matches\n    if (payloadV1.network !== requirements.network) {\n      return {\n        isValid: false,\n        invalidReason: \"network_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Build typed data for signature verification\n    const permitTypedData = {\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\" as const,\n      domain: {\n        name,\n        version,\n        chainId,\n        verifyingContract: erc20Address,\n      },\n      message: {\n        from: exactEvmPayload.authorization.from,\n        to: exactEvmPayload.authorization.to,\n        value: BigInt(exactEvmPayload.authorization.value),\n        validAfter: BigInt(exactEvmPayload.authorization.validAfter),\n        validBefore: BigInt(exactEvmPayload.authorization.validBefore),\n        nonce: exactEvmPayload.authorization.nonce,\n      },\n    };\n\n    // Verify signature\n    try {\n      const recoveredAddress = await this.signer.verifyTypedData({\n        address: exactEvmPayload.authorization.from,\n        ...permitTypedData,\n        signature: exactEvmPayload.signature!,\n      });\n\n      if (!recoveredAddress) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // Signature verification failed - could be an undeployed smart wallet\n      // Check if smart wallet is deployed\n      const signature = exactEvmPayload.signature!;\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n      if (isSmartWallet) {\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n          // EIP-6492 signatures contain factory address and calldata needed for deployment.\n          // Non-EIP-6492 undeployed wallets cannot succeed (no way to deploy them).\n          const erc6492Data = parseErc6492Signature(signature);\n          const hasDeploymentInfo =\n            erc6492Data.address &&\n            erc6492Data.data &&\n            !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n          if (!hasDeploymentInfo) {\n            // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n            // since EIP-3009 requires on-chain EIP-1271 validation\n            return {\n              isValid: false,\n              invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n              payer: payerAddress,\n            };\n          }\n          // EIP-6492 signature with deployment info - allow through\n          // Facilitators with sponsored deployment support can handle this in settle()\n        } else {\n          // Wallet is deployed but signature still failed - invalid signature\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_signature\",\n            payer: exactEvmPayload.authorization.from,\n          };\n        }\n      } else {\n        // EOA signature failed\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    }\n\n    // Verify payment recipient matches\n    if (getAddress(exactEvmPayload.authorization.to) !== getAddress(requirements.payTo)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validBefore is in the future (with 6 second buffer for block time)\n    const now = Math.floor(Date.now() / 1000);\n    if (BigInt(exactEvmPayload.authorization.validBefore) < BigInt(now + 6)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validAfter is not in the future\n    if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(now)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Check balance\n    try {\n      const balance = (await this.signer.readContract({\n        address: erc20Address,\n        abi: eip3009ABI,\n        functionName: \"balanceOf\",\n        args: [exactEvmPayload.authorization.from],\n      })) as bigint;\n\n      if (BigInt(balance) < BigInt(requirementsV1.maxAmountRequired)) {\n        return {\n          isValid: false,\n          invalidReason: \"insufficient_funds\",\n          invalidMessage: `Insufficient funds to complete the payment. Required: ${requirementsV1.maxAmountRequired} ${requirements.asset}, Available: ${balance.toString()} ${requirements.asset}. Please add funds to your wallet and try again.`,\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // If we can't check balance, continue with other validations\n    }\n\n    // Verify amount is sufficient\n    if (BigInt(exactEvmPayload.authorization.value) < BigInt(requirementsV1.maxAmountRequired)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  /**\n   * Settles a payment by executing the transfer (V1).\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV1;\n\n    // Re-verify before settling\n    const valid = await this.verify(payload, requirements);\n    if (!valid.isValid) {\n      return {\n        success: false,\n        network: payloadV1.network,\n        transaction: \"\",\n        errorReason: valid.invalidReason ?? \"invalid_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    try {\n      // Parse ERC-6492 signature if applicable\n      const parseResult = parseErc6492Signature(exactEvmPayload.signature!);\n      const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n      // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n      if (\n        this.config.deployERC4337WithEIP6492 &&\n        factoryAddress &&\n        factoryCalldata &&\n        !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n      ) {\n        // Check if smart wallet is already deployed\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet not deployed - attempt deployment\n          try {\n            console.log(`Deploying ERC-4337 smart wallet for ${payerAddress} via EIP-6492`);\n\n            // Send the factory calldata directly as a transaction\n            // The factoryCalldata already contains the complete encoded function call\n            const deployTx = await this.signer.sendTransaction({\n              to: factoryAddress as Hex,\n              data: factoryCalldata as Hex,\n            });\n\n            // Wait for deployment transaction\n            await this.signer.waitForTransactionReceipt({ hash: deployTx });\n            console.log(`Successfully deployed smart wallet for ${payerAddress}`);\n          } catch (deployError) {\n            console.error(\"Smart wallet deployment failed:\", deployError);\n            // Deployment failed - cannot proceed\n            throw deployError;\n          }\n        } else {\n          console.log(`Smart wallet for ${payerAddress} already deployed, skipping deployment`);\n        }\n      }\n\n      // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n      // ECDSA signatures are exactly 65 bytes (130 hex chars without 0x)\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isECDSA = signatureLength === 130;\n\n      let tx: Hex;\n      if (isECDSA) {\n        // For EOA wallets, parse signature into v, r, s and use that overload\n        const parsedSig = parseSignature(signature);\n\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            (parsedSig.v as number | undefined) || parsedSig.yParity,\n            parsedSig.r,\n            parsedSig.s,\n          ],\n        });\n      } else {\n        // For smart wallets, use the bytes signature overload\n        // The signature contains WebAuthn/P256 or other ERC-1271 compatible signature data\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            signature,\n          ],\n        });\n      }\n\n      // Wait for transaction confirmation\n      const receipt = await this.signer.waitForTransactionReceipt({ hash: tx });\n\n      if (receipt.status !== \"success\") {\n        return {\n          success: false,\n          errorReason: \"invalid_transaction_state\",\n          transaction: tx,\n          network: payloadV1.network,\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n\n      return {\n        success: true,\n        transaction: tx,\n        network: payloadV1.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    } catch (error) {\n      console.error(\"Failed to settle transaction:\", error);\n      return {\n        success: false,\n        errorReason: \"transaction_failed\",\n        transaction: \"\",\n        network: payloadV1.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n  }\n}\n","import {\n  Network,\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkClient,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../../constants\";\nimport { ClientEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { createNonce } from \"../../../utils\";\nimport { EvmNetworkV1, getEvmChainIdV1 } from \"../../../v1\";\n\n/**\n * EVM client implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClientV1 instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme (V1).\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<\n    Pick<PaymentPayload, \"x402Version\" | \"payload\"> & { scheme: string; network: Network }\n  > {\n    const selectedV1 = paymentRequirements as unknown as PaymentRequirementsV1;\n    const nonce = createNonce();\n    const now = Math.floor(Date.now() / 1000);\n\n    const authorization: ExactEvmPayloadV1[\"authorization\"] = {\n      from: this.signer.address,\n      to: getAddress(selectedV1.payTo),\n      value: selectedV1.maxAmountRequired,\n      validAfter: (now - 600).toString(), // 10 minutes before\n      validBefore: (now + selectedV1.maxTimeoutSeconds).toString(),\n      nonce,\n    };\n\n    // Sign the authorization\n    const signature = await this.signAuthorization(authorization, selectedV1);\n\n    const payload: ExactEvmPayloadV1 = {\n      authorization,\n      signature,\n    };\n\n    return {\n      x402Version,\n      scheme: selectedV1.scheme,\n      network: selectedV1.network,\n      payload,\n    };\n  }\n\n  /**\n   * Sign the EIP-3009 authorization using EIP-712\n   *\n   * @param authorization - The authorization to sign\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to the signature\n   */\n  private async signAuthorization(\n    authorization: ExactEvmPayloadV1[\"authorization\"],\n    requirements: PaymentRequirementsV1,\n  ): Promise<`0x${string}`> {\n    const chainId = getEvmChainIdV1(requirements.network as EvmNetworkV1);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      throw new Error(\n        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n      );\n    }\n\n    const { name, version } = requirements.extra;\n\n    const domain = {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(requirements.asset),\n    };\n\n    const message = {\n      from: getAddress(authorization.from),\n      to: getAddress(authorization.to),\n      value: BigInt(authorization.value),\n      validAfter: BigInt(authorization.validAfter),\n      validBefore: BigInt(authorization.validBefore),\n      nonce: authorization.nonce,\n    };\n\n    return await this.signer.signTypedData({\n      domain,\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\",\n      message,\n    });\n  }\n}\n","export { ExactEvmSchemeV1 } from \"../exact/v1\";\n\nexport const EVM_NETWORK_CHAIN_ID_MAP = {\n  ethereum: 1,\n  sepolia: 11155111,\n  abstract: 2741,\n  \"abstract-testnet\": 11124,\n  \"base-sepolia\": 84532,\n  base: 8453,\n  \"avalanche-fuji\": 43113,\n  avalanche: 43114,\n  iotex: 4689,\n  sei: 1329,\n  \"sei-testnet\": 1328,\n  polygon: 137,\n  \"polygon-amoy\": 80002,\n  peaq: 3338,\n  story: 1514,\n  educhain: 41923,\n  \"skale-base-sepolia\": 324705682,\n  megaeth: 4326,\n  monad: 143,\n} as const;\n\nexport type EvmNetworkV1 = keyof typeof EVM_NETWORK_CHAIN_ID_MAP;\n\nexport const NETWORKS: string[] = Object.keys(EVM_NETWORK_CHAIN_ID_MAP);\n\n/**\n * Extract chain ID from a v1 legacy network name.\n *\n * @param network - The v1 network name (e.g., \"base-sepolia\", \"polygon\")\n * @returns The numeric chain ID\n * @throws Error if the network name is not a known v1 network\n */\nexport function getEvmChainIdV1(network: string): number {\n  const chainId = EVM_NETWORK_CHAIN_ID_MAP[network as EvmNetworkV1];\n  if (!chainId) {\n    throw new Error(`Unsupported v1 network: ${network}`);\n  }\n  return chainId;\n}\n","import { x402Facilitator } from \"@x402/core/facilitator\";\nimport { Network } from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/facilitator/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Facilitator\n */\nexport interface EvmFacilitatorConfig {\n  /**\n   * The EVM signer for facilitator operations (verify and settle)\n   */\n  signer: FacilitatorEvmSigner;\n\n  /**\n   * Networks to register (single network or array of networks)\n   * Examples: \"eip155:84532\", [\"eip155:84532\", \"eip155:1\"]\n   */\n  networks: Network | Network[];\n\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Facilitator instance.\n *\n * This function registers:\n * - V2: Specified networks with ExactEvmScheme\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param facilitator - The x402Facilitator instance to register schemes to\n * @param config - Configuration for EVM facilitator registration\n * @returns The facilitator instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/facilitator/register\";\n * import { x402Facilitator } from \"@x402/core/facilitator\";\n * import { createPublicClient, createWalletClient } from \"viem\";\n *\n * const facilitator = new x402Facilitator();\n *\n * // Single network\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: \"eip155:84532\"  // Base Sepolia\n * });\n *\n * // Multiple networks (will auto-derive eip155:* pattern)\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: [\"eip155:84532\", \"eip155:1\"]  // Base Sepolia and Mainnet\n * });\n * ```\n */\nexport function registerExactEvmScheme(\n  facilitator: x402Facilitator,\n  config: EvmFacilitatorConfig,\n): x402Facilitator {\n  // Register V2 scheme with specified networks\n  facilitator.register(\n    config.networks,\n    new ExactEvmScheme(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  // Register all V1 networks\n  facilitator.registerV1(\n    NETWORKS as Network[],\n    new ExactEvmSchemeV1(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  return facilitator;\n}\n"],"mappings":"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","names":["import_viem","import_extensions","import_viem","import_viem","import_viem","import_viem","ExactEvmSchemeV1","ExactEvmSchemeV1"]}